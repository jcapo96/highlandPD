//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundPLEASE(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 21;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundPLEASE);

  Double_t arglist[11];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,sgwA,sgwB,sgwC,snorm;
  double slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,sgwA_error,sgwB_error,sgwC_error,snorm_error;
  double sslwA,sslwB,ssmpvA,ssmpvB,ssmpvC,ssgw,ssnorm;
  double sslwA_error,sslwB_error,ssmpvA_error,ssmpvB_error,ssmpvC_error,ssgw_error,ssnorm_error;
  double blw, bmpv, bgw, bnorm, bC;
  double blw_error, bmpv_error, bnorm_error, bgw_error, bC_error;
  
  slwA  = fSignal->fClwA.first;         slwA_error  = fSignal->fClwA.second;  
  slwB  = fSignal->fClwB.first;		slwB_error  = fSignal->fClwB.second;  
  slwC  = fSignal->fClwC.first;		slwC_error  = fSignal->fClwC.second;  
  smpvA = fSignal->fCmpvA.first;	smpvA_error = fSignal->fCmpvA.second;
  smpvB = fSignal->fCmpvB.first;	smpvB_error = fSignal->fCmpvB.second; 
  smpvC = fSignal->fCmpvC.first;	smpvC_error = fSignal->fCmpvC.second; 
  smpvD = fSignal->fCmpvD.first;	smpvD_error = fSignal->fCmpvD.second; 
  sgwA  = fSignal->fCgwA.first;		sgwA_error  = fSignal->fCgwA.second;  
  sgwB  = fSignal->fCgwB.first;		sgwB_error  = fSignal->fCgwB.second;  
  sgwC  = fSignal->fCgwC.first;		sgwC_error  = fSignal->fCgwC.second;  
  snorm = fSignal->fCnorm.first;	snorm_error = fSignal->fCnorm.second;

  sslwA  = fSignal->fSemiSignal->fClwA.first;        sslwA_error  = fSignal->fSemiSignal->fClwA.second;  
  sslwB  = fSignal->fSemiSignal->fClwB.first;	     sslwB_error  = fSignal->fSemiSignal->fClwB.second;  
  ssmpvA = fSignal->fSemiSignal->fCmpvA.first;       ssmpvA_error = fSignal->fSemiSignal->fCmpvA.second;
  ssmpvB = fSignal->fSemiSignal->fCmpvB.first;	     ssmpvB_error = fSignal->fSemiSignal->fCmpvB.second; 
  ssmpvC = fSignal->fSemiSignal->fCmpvC.first;	     ssmpvC_error = fSignal->fSemiSignal->fCmpvC.second; 
  ssgw   = fSignal->fSemiSignal->fCgwA.first;	     ssgw_error   = fSignal->fSemiSignal->fCgwA.second;

  blw   = fBackground->fClwA.first;
  bmpv  = fBackground->fCmpvA.first;
  bgw   = fBackground->fCgwA.first;
  bnorm = fBackground->fCnorm.first;
  bC    = 0;//fBackground->fCconst.first;
  
  fMinuit->mnparm(0,  "slw A"  , slwA   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(1,  "slw A"  , slwB   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(2,  "slw A"  , slwC   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(3,  "smpv A" , smpvA  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(4,  "smpv B" , smpvB  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(5,  "smpv C" , smpvC  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(6,  "smpv D" , smpvD  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(7,  "sgw A"  , sgwA   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(8,  "sgw B"  , sgwB   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(9,  "sgw C"  , sgwC   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(10, "snorm"  , snorm  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(11, "sslw A" , sslwA  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(12, "sslw B" , sslwB  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(13, "ssmpv A", ssmpvA , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(14, "ssmpv B", ssmpvB , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(15, "ssgw"   , ssgw   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(16, "blw"    , blw    , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(17, "bmpv"   , bmpv   , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(18, "bgw"    , bgw    , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(19, "bnorm"  , bnorm  , 0.1, 0   , 0   , ierflg);
  fMinuit->mnparm(20, "bconst" , bC     , 0.1, 0   , 0   , ierflg);

  fMinuit->FixParameter(20);
  
  // Now ready for minimization step
  // arglist[0] = 2;
  // fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  arglist[0] = 500000;
  arglist[1] = 1.;
  // fMinuit->mnexcm("HESSE", arglist, 1, ierflg);
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);

  // arglist[0] = 2;
  // fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  // arglist[0] = 500000;
  // arglist[1] = 1.;
  // fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage

  //SIGNAL
  fMinuit->GetParameter(0 , slwA , slwA_error );
  fMinuit->GetParameter(1 , slwB , slwB_error );
  fMinuit->GetParameter(2 , slwC , slwC_error );
  fMinuit->GetParameter(3 , smpvA, smpvA_error);
  fMinuit->GetParameter(4 , smpvB, smpvB_error);
  fMinuit->GetParameter(5 , smpvC, smpvC_error);
  fMinuit->GetParameter(6 , smpvD, smpvD_error);
  fMinuit->GetParameter(7 , sgwA , sgwA_error );
  fMinuit->GetParameter(8 , sgwB , sgwB_error );
  fMinuit->GetParameter(9 , sgwC , sgwC_error );
  fMinuit->GetParameter(10, snorm, snorm_error);

  fSignal->SetClwA(std::make_pair(slwA  ,slwA_error ));
  fSignal->SetClwB(std::make_pair(slwB  ,slwB_error ));
  fSignal->SetClwC(std::make_pair(slwC  ,slwC_error ));
  fSignal->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  fSignal->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  fSignal->SetCmpvC(std::make_pair(smpvC,smpvC_error));
  fSignal->SetCmpvD(std::make_pair(smpvD,smpvD_error));
  fSignal->SetCgwA(std::make_pair(sgwA  ,sgwA_error ));
  fSignal->SetCgwB(std::make_pair(sgwB  ,sgwB_error ));
  fSignal->SetCgwC(std::make_pair(sgwC  ,sgwC_error ));
  fSignal->SetCnorm(std::make_pair(snorm,snorm_error));

  //BACKGROUND
  fMinuit->GetParameter(16, blw  , blw_error);
  fMinuit->GetParameter(17, bmpv , bmpv_error);
  fMinuit->GetParameter(18, bgw  , bgw_error);
  fMinuit->GetParameter(19, bnorm, bnorm_error);
  fMinuit->GetParameter(20, bC   , bC_error);

  fBackground->SetClwA(std::make_pair(blw   ,blw_error));
  fBackground->SetCmpvA(std::make_pair(bmpv ,bmpv_error));
  fBackground->SetCgwA(std::make_pair(bgw   ,bgw_error));
  fBackground->SetCnorm(std::make_pair(bnorm,bnorm_error));
  fBackground->SetCconst(std::make_pair(bC  ,bC_error));

  //SEMISIGNAL
  fMinuit->GetParameter(11, sslwA ,sslwA_error);
  fMinuit->GetParameter(12, sslwB ,sslwB_error);
  fMinuit->GetParameter(13, ssmpvA,ssmpvA_error);
  fMinuit->GetParameter(14, ssmpvB,ssmpvB_error);
  fMinuit->GetParameter(15, ssgw  ,ssgw_error);
  ssnorm = 1-snorm-bnorm;
  ssnorm_error = sqrt(pow(snorm_error,2)+pow(bnorm_error,2));

  fSignal->fSemiSignal->SetClwA(std::make_pair(sslwA  ,sslwA_error));
  fSignal->fSemiSignal->SetClwB(std::make_pair(sslwB  ,sslwB_error));
  fSignal->fSemiSignal->SetCmpvA(std::make_pair(ssmpvA,ssmpvA_error));
  fSignal->fSemiSignal->SetCmpvB(std::make_pair(ssmpvB,ssmpvB_error));
  fSignal->fSemiSignal->SetCmpvC(std::make_pair(ssmpvC,ssmpvC_error));
  fSignal->fSemiSignal->SetCgwA(std::make_pair(ssgw   ,ssgw_error));
  fSignal->fSemiSignal->SetCnorm(std::make_pair(ssnorm,ssnorm_error));
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundPLEASE(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwA    = par[0];
  double lwB    = par[1];
  double lwC    = par[2];
  double mpvA   = par[3];
  double mpvB   = par[4];
  double mpvC   = par[5];
  double mpvD   = par[6];
  double gwA    = par[7];
  double gwB    = par[8];
  double gwC    = par[9];
  double norm   = par[10];
  double sslwA  = par[11];
  double sslwB  = par[12];
  double ssmpvA = par[13];
  double ssmpvB = par[14];
  double ssgw   = par[15];
  double blw    = par[16];
  double bmpv   = par[17];
  double bgw    = par[18];
  double bnorm  = par[19];
  double bC     = par[20];

  //define function to fit to each histogram
  double lw,mpv,gw,sslw,ssmpv,ssnorm;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::TripleLangausPlusConstant,1,30,13);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = CSMinuit->fRR[ibin].first;
    double x_t = (x-1)/(x+1);
    mpv  = mpvA*ROOT::Math::laguerre(0,x_t)+mpvB*ROOT::Math::laguerre(1,x_t)+mpvC*ROOT::Math::laguerre(2,x_t)+mpvD*ROOT::Math::laguerre(3,x_t);
    lw   = lwA*ROOT::Math::laguerre(0,x_t)+lwB*ROOT::Math::laguerre(1,x_t)+lwC*ROOT::Math::laguerre(2,x_t);
    gw   = gwA*ROOT::Math::laguerre(0,x_t)+gwB*ROOT::Math::laguerre(1,x_t)+gwC*ROOT::Math::laguerre(2,x_t);

    ssmpv = ssmpvA + ssmpvB*x;
    sslw = sslwA+sslwB+ssmpv;//*pow(sslwB+ssmpv,2);
    ssnorm = 1-norm-bnorm;
    
    double params[] = {lw,mpv,norm,gw,sslw,ssmpv,ssnorm,ssgw,blw,bmpv,bnorm,bgw,bC};
    flg->SetParameters(params);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
    // CSMinuit->fh[ibin]->Draw();
    // flg->Draw("same");
    // gPad->Update();
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundMiau(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 16;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundMiau);
  
  Double_t arglist[10];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //initial par
  fMinuit->mnparm(0,  "slw"   ,  6.54009e-02   , 0.01 ,0.05,0.2, ierflg);// 5.73423e-02
  fMinuit->mnparm(1,  "mpv A" , -7.80258e+01   , 1  ,0   ,0  , ierflg);//-6.79884e+01
  fMinuit->mnparm(2,  "mpv B" ,  2.94836e+02   , 10 ,0  ,0  , ierflg);// 2.64140e+02
  fMinuit->mnparm(3,  "mpv C" , -3.40926e+02   , 10 ,0   ,0  , ierflg);//-3.07377e+02
  fMinuit->mnparm(4,  "mpv D" ,  1.36051e+02   , 10 ,0   ,0  , ierflg);// 1.25650e+02
  fMinuit->mnparm(5,  "gw A"  ,  3.47349e+00   , 0.1 ,0   ,0  , ierflg);// 3.60804e+00
  fMinuit->mnparm(6,  "gw B"  , -3.67669e+00   , 0.1 ,0   ,0  , ierflg);//-3.82723e+00
  fMinuit->mnparm(7,  "gw C"  ,  1.03260e+00   , 0.1 ,0   ,0  , ierflg);// 1.07999e+00
  fMinuit->mnparm(8,  "blw"   ,  9.63250e-02   , 0.1,0,0, ierflg);
  fMinuit->mnparm(9,  "bmpv"  ,  1.68322e+00   , 0.1,0,0, ierflg);
  fMinuit->mnparm(10, "bgw"   ,  6.82935e-02   , 0.01 ,0,0, ierflg);
  fMinuit->mnparm(11, "snorm" ,  3.78360e-01   , 0.01 ,0,1, ierflg);
  fMinuit->mnparm(12, "const" ,  0.001         , 0.001 ,0,0, ierflg);
  fMinuit->mnparm(13, "mu"   ,  3   , 0.01 ,0,0, ierflg);
  fMinuit->mnparm(14, "sigma" ,  3   , 0.01 ,0,1, ierflg);
  fMinuit->mnparm(15, "norm" ,  0.1         , 0.001 ,0,0, ierflg);

  // arglist[0] = 2;
  // fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);

  fMinuit->mnexcm("SHO EIG", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  double dummy;
  double lwA;
  double smpvA,smpvB,smpvC,smpvD,sgwA,sgwB,sgwC,norm;
  double shift,ssgwA,ssgwB,ssgwC,ssnorm,alpha;
  double blw,bmpv,bgw,bnorm;
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  lwA  , dummy);
  fMinuit->GetParameter(1,  smpvA , dummy);
  fMinuit->GetParameter(2,  smpvB , dummy);
  fMinuit->GetParameter(3,  smpvC , dummy);
  fMinuit->GetParameter(4,  smpvD , dummy);
  fMinuit->GetParameter(5,  sgwA  , dummy);
  fMinuit->GetParameter(6,  sgwB  , dummy);
  fMinuit->GetParameter(7,  sgwC  , dummy);
  fMinuit->GetParameter(8,  blw  , dummy);
  fMinuit->GetParameter(9,  bmpv  , dummy);
  fMinuit->GetParameter(10,  bgw   , dummy);
  // fMinuit->GetParameter(11, shift , dummy);
  // fMinuit->GetParameter(12,  ssgwA  , dummy);
  // fMinuit->GetParameter(13,  ssgwB  , dummy);
  // fMinuit->GetParameter(14,  ssgwC  , dummy);
  fMinuit->GetParameter(11,  norm   , dummy);
  //fMinuit->GetParameter(12,  bnorm   , dummy);
  // fMinuit->GetParameter(16,  alpha  , dummy);

  GetSignal()->SetClwA(std::make_pair(lwA  ,dummy));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,dummy));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,dummy));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,dummy));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,dummy));
  GetSignal()->SetCgwA(std::make_pair(sgwA  ,dummy));
  GetSignal()->SetCgwB(std::make_pair(sgwB  ,dummy));
  GetSignal()->SetCgwC(std::make_pair(sgwC  ,dummy));
  GetSignal()->SetCnorm(std::make_pair(norm ,dummy));

  GetBackground()->SetClwA(std::make_pair(lwA,dummy));
  GetBackground()->SetCmpvA(std::make_pair(bmpv,dummy));
  GetBackground()->SetCgwA(std::make_pair(bgw,dummy));
  GetBackground()->SetCnorm(std::make_pair(bnorm,dummy));
  
  GetSemiSignal()->SetCshift(std::make_pair(shift,dummy));
  GetSemiSignal()->SetCgwA(std::make_pair(ssgwA,dummy));
  GetSemiSignal()->SetCgwB(std::make_pair(ssgwB,dummy));
  GetSemiSignal()->SetCgwC(std::make_pair(ssgwC,dummy));
  GetSemiSignal()->SetCnorm(std::make_pair(bnorm*alpha,dummy));

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundMiau(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lw    = par[0];
  double smpvA = par[1];
  double smpvB = par[2];
  double smpvC = par[3];
  double smpvD = par[4];
  double sgwA  = par[5];
  double sgwB  = par[6];
  double sgwC  = par[7];
  double blw   = par[8];
  double bmpv  = par[9];
  double bgw   = par[10];
  double snorm = par[11];
  double C     = par[12];
  double mu   = par[13];
  double sigma = par[14];
  double norm     = par[15];

  //define function to fit to each histogram
  double smpv,sgw,bnorm;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangausPlusGausPlusConstant,1,30,12);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x    = CSMinuit->fRR[ibin].first;
    double x_t  = (x-1)/(x+1);

    smpv  = smpvA*ROOT::Math::laguerre(0,x_t) + smpvB*ROOT::Math::laguerre(1,x_t) + smpvC*ROOT::Math::laguerre(2,x_t) + smpvD*ROOT::Math::laguerre(3,x_t);
    sgw   = sgwA + sgwB*sqrt(smpv) + sgwC*smpv;

    bnorm = 1-snorm;
    
    double params[] = {lw,smpv,snorm,sgw,norm,mu,sigma,blw,bmpv,bnorm,bgw,C};
    flg->SetParameters(params);
    // CSMinuit->fh[ibin]->Draw();
    // flg->Draw("same");
    // gPad->Update();
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSemiSignal(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 4;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSemiSignal);

  Double_t arglist[11];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //Set starting values and step sizes for parameters
  double mean_norm = 0;
  for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  mean_norm = 0.06;//mean_norm / fInorm.size();

  //fMinuit->mnparm(0,  "lw Q" , 0       , 10 , 0 , 0 , ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(0,  "mpv S", 3.4     , 10 , 0 , 0 , ierflg);//0.9*0.65  , 1.1*0.65  , ierflg);//
  fMinuit->mnparm(1,  "gw A" , 0.1      , 10 , 0 , 0 , ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(2,  "norm" , mean_norm , 0.01  , 0 , 1 , ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//
  fMinuit->mnparm(3,  "const" , 0.001 , 0.01  , 0 , 1 , ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//

  // fMinuit->FixParameter(1);
  //fMinuit->FixParameter(2);

  // Now ready for minimization step
  arglist[0] = 500000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
 
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  //fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(0,  fCshift.first,  fCshift.second);
  fMinuit->GetParameter(1,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(2,  fCnorm.first, fCnorm.second);
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSemiSignal(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  //double lwQ   = par[0];
  double shift = par[0];
  double gwA   = par[1];
  double norm  = par[2];
  double C     = par[3];

  double smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;

  double slwA = CSMinuit->GetTrueSignal()->GetClwA().first;
  double slwB = CSMinuit->GetTrueSignal()->GetClwB().first;
  double slwC = CSMinuit->GetTrueSignal()->GetClwC().first;

  double sgwA = CSMinuit->GetTrueSignal()->GetCgwA().first;
  double sgwB = CSMinuit->GetTrueSignal()->GetCgwB().first;
  double sgwC = CSMinuit->GetTrueSignal()->GetCgwC().first;
      
  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  //TF1* flg = new TF1("flg",CoherentFitUtils::LangausPlusConstant,1,30,5);
  TF1* flg = new TF1("flg","gaus(0)+pol0(3)",1,30);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = CSMinuit->fRR[ibin].first+shift;
    double x_t = (x-1)/(x+1);
    mpv  = smpvA*ROOT::Math::laguerre(0,x_t)+smpvB*ROOT::Math::laguerre(1,x_t)+smpvC*ROOT::Math::laguerre(2,x_t)+smpvD*ROOT::Math::laguerre(3,x_t);
    //lw   = sqrt(pow(slwA + slwB*sqrt(mpv)+slwC*mpv,2) + pow(lwQ,2));
    //gw   = sqrt(pow(sgwA + sgwB*sqrt(mpv)+sgwC*mpv,2) + pow(gwQ,2));
    //flg->SetParameters(lw,mpv,norm,gw,C);
    gw = gwA*mpv;
    flg->SetParameters(norm,mpv,gw,C);
    CSMinuit->fh[ibin]->Draw();
    flg->Draw("same");
    gPad->Update();
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalMiau(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 17;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalMiau);

  Double_t arglist[11];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //Set starting values and step sizes for parameters
  double lwA,lwB,lwC,mpvA,mpvB,mpvC,mpvD,gwA,gwB,gwC,norm;
  double lwA_error,lwB_error,lwC_error,mpvA_error,mpvB_error,mpvC_error,mpvD_error,gwA_error,gwB_error,gwC_error,norm_error;
  double sslwA,sslwB,ssmpvA,ssmpvB,ssmpvC,ssgw,ssnorm;
  double sslwA_error,sslwB_error,ssmpvA_error,ssmpvB_error,ssmpvC_error,ssgw_error,ssnorm_error;

  lwA  = fClwA.first;           lwA_error  = fClwA.second;  
  lwB  = fClwB.first;		lwB_error  = fClwB.second;  
  lwC  = fClwC.first;		lwC_error  = fClwC.second;  
  mpvA = fCmpvA.first;		mpvA_error = fCmpvA.second;
  mpvB = fCmpvB.first;		mpvB_error = fCmpvB.second; 
  mpvC = fCmpvC.first;		mpvC_error = fCmpvC.second; 
  mpvD = fCmpvD.first;		mpvD_error = fCmpvD.second; 
  gwA  = fCgwA.first;		gwA_error  = fCgwA.second;  
  gwB  = fCgwB.first;		gwB_error  = fCgwB.second;  
  gwC  = fCgwC.first;		gwC_error  = fCgwC.second;  
  norm = fCnorm.first;		norm_error = fCnorm.second;

  sslwA  = fTrueSemiSignal->fClwA.first;        sslwA_error  = fTrueSemiSignal->fClwA.second;  
  sslwB  = fTrueSemiSignal->fClwB.first;	sslwB_error  = fTrueSemiSignal->fClwB.second;  
  ssmpvA = fTrueSemiSignal->fCmpvA.first;       ssmpvA_error = fTrueSemiSignal->fCmpvA.second;
  ssmpvB = fTrueSemiSignal->fCmpvB.first;	ssmpvB_error = fTrueSemiSignal->fCmpvB.second; 
  ssmpvC = fTrueSemiSignal->fCmpvC.first;	ssmpvC_error = fTrueSemiSignal->fCmpvC.second; 
  ssgw   = fTrueSemiSignal->fCgwA.first;	ssgw_error   = fTrueSemiSignal->fCgwA.second;  
  ssnorm = fTrueSemiSignal->fCnorm.first;	ssnorm_error = fTrueSemiSignal->fCnorm.second;

  fMinuit->mnparm(0,  "slw A" , lwA    , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(1,  "slw B" , lwB    , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(2,  "slw C" , lwC    , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(3,  "smpv A", mpvA   , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(4,  "smpv B", mpvB   , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(5,  "smpv C", mpvC   , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(6,  "smpv D", mpvD   , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(7,  "sgw A" , gwA    , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(8,  "sgw B" , gwB    , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(9,  "sgw C" , gwC    , 0.0000001, 0, 0, ierflg);
  fMinuit->mnparm(10, "snorm" , norm   , 0.1, 0, 0.5, ierflg);
  fMinuit->mnparm(11, "blw A" , sslwA  , 0.1, 0, 0, ierflg);
  fMinuit->mnparm(12, "blw B" , sslwB  , 0.1, 0, 0, ierflg);
  fMinuit->mnparm(13, "bmpv A", ssmpvA , 0.1, 0, 0, ierflg);
  fMinuit->mnparm(14, "bmpv B", ssmpvB , 0.1, 0, 0, ierflg);
  fMinuit->mnparm(15, "bgw"   , ssgw   , 0.1, 0, 0, ierflg);
  fMinuit->mnparm(16, "bnorm" , ssnorm , 0.1, 0, 0.15, ierflg);

  //Now ready for minimization step
  arglist[0] = 2;
  fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  arglist[0] = 500000;
  arglist[1] = 1;
  fMinuit->mnexcm("HESSE", arglist, 1, ierflg);
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  //fMinuit->mnexcm("MINOS", arglist, 2, ierflg);

  arglist[0] = 2;
  fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  arglist[0] = 500000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);

  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(1,  fClwB.first,  fClwB.second);
  fMinuit->GetParameter(2,  fClwC.first,  fClwC.second);
  fMinuit->GetParameter(3,  fCmpvA.first, fCmpvA.second);
  fMinuit->GetParameter(4,  fCmpvB.first, fCmpvB.second);
  fMinuit->GetParameter(5,  fCmpvC.first, fCmpvC.second);
  fMinuit->GetParameter(6,  fCmpvD.first, fCmpvD.second);
  fMinuit->GetParameter(7,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(8,  fCgwB.first,  fCgwB.second);
  fMinuit->GetParameter(9,  fCgwC.first,  fCgwC.second);
  fMinuit->GetParameter(10, fCnorm.first, fCnorm.second);

  fMinuit->GetParameter(11, fTrueSemiSignal->fClwA.first,  fTrueSemiSignal->fClwA.second);
  fMinuit->GetParameter(12, fTrueSemiSignal->fClwB.first,  fTrueSemiSignal->fClwB.second);
  fMinuit->GetParameter(13, fTrueSemiSignal->fCmpvA.first, fTrueSemiSignal->fCmpvA.second);
  fMinuit->GetParameter(14, fTrueSemiSignal->fCmpvB.first, fTrueSemiSignal->fCmpvB.second);
  fMinuit->GetParameter(15, fTrueSemiSignal->fCgwA.first,  fTrueSemiSignal->fCgwA.second);
  fMinuit->GetParameter(16, fTrueSemiSignal->fCnorm.first, fTrueSemiSignal->fCnorm.second);

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalMiau(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwA   = par[0];
  double lwB   = par[1];
  double lwC   = par[2];
  double mpvA  = par[3];
  double mpvB  = par[4];
  double mpvC  = par[5];
  double mpvD  = par[6];
  double gwA   = par[7];
  double gwB   = par[8];
  double gwC   = par[9];
  double norm  = par[10];
  double blwA  = par[11];
  double blwB  = par[12];
  double bmpvA = par[13];
  double bmpvB = par[14];
  double bgw   = par[15];
  double bnorm = par[16];
  
  //define function to fit to each histogram
  double lw,mpv,gw,blw,bmpv;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = CSMinuit->fRR[ibin].first;
    double x_t = (x-1)/(x+1);
    mpv  = mpvA*ROOT::Math::laguerre(0,x_t)+mpvB*ROOT::Math::laguerre(1,x_t)+mpvC*ROOT::Math::laguerre(2,x_t)+mpvD*ROOT::Math::laguerre(3,x_t);
    lw   = lwA*ROOT::Math::laguerre(0,x_t)+lwB*ROOT::Math::laguerre(1,x_t)+lwC*ROOT::Math::laguerre(2,x_t);
    gw   = gwA*ROOT::Math::laguerre(0,x_t)+gwB*ROOT::Math::laguerre(1,x_t)+gwC*ROOT::Math::laguerre(2,x_t);
            
    bmpv = bmpvA + bmpvB*x;
    blw = blwA+blwB*bmpv;//*pow(bmpv+blwB,2);

    flg->SetParameters(lw,mpv,norm,gw,blw,bmpv,bnorm,bgw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
    // CSMinuit->fh[ibin]->Draw();
    // flg->Draw("same");
    // gPad->Update();//gPad->WaitPrimitive();
  }
  f = -Likelihood;
}

//DEFAULT MODEL

//********************************************************************
void CoherentSample::CoherentFitSignal(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 11+1;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignal);
  
  Double_t arglist[10];
  Int_t ierflg = 0;

  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {fClwA.first, fClwB.first, fClwC.first,
 			   fCmpvA.first, fCmpvB.first, fCmpvC.first, fCmpvD.first, fCmpvR.first,
 			   fCgwA.first, fCgwB.first, fCgwC.first};
  Double_t step[NPAR]   = { 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01};
  double mean_norm = 0;
  for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  mean_norm = mean_norm / fInorm.size();
  
  fMinuit->mnparm(0,  "lw A",  vstart[0],  step[0],  0, 0, ierflg);
  fMinuit->mnparm(1,  "lw B",  vstart[1],  step[1],  0, 0, ierflg);
  fMinuit->mnparm(2,  "lw C",  vstart[2],  step[2],  0, 0, ierflg);
  fMinuit->mnparm(3,  "mpv A", vstart[3],  step[3],  0, 0, ierflg);
  fMinuit->mnparm(4,  "mpv B", vstart[4],  step[4],  0, 0, ierflg);
  fMinuit->mnparm(5,  "mpv C", vstart[5],  step[5],  0, 0, ierflg);
  fMinuit->mnparm(6,  "mpv D", vstart[6],  step[6],  0, 0, ierflg);
  fMinuit->mnparm(7,  "mpv R", vstart[7],  step[7],  0, 0, ierflg);
  fMinuit->mnparm(8,  "gw A",  vstart[8],  step[8],  0, 0, ierflg);
  fMinuit->mnparm(9,  "gw B",  vstart[9],  step[9],  0, 0, ierflg);
  fMinuit->mnparm(10, "gw C",  vstart[10], step[10], 0, 0, ierflg);
  fMinuit->mnparm(11, "norm",  mean_norm, 0.01, 0, 1.2, ierflg);
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(1,  fClwB.first,  fClwB.second);
  fMinuit->GetParameter(2,  fClwC.first,  fClwC.second);
  fMinuit->GetParameter(3,  fCmpvA.first, fCmpvA.second);
  fMinuit->GetParameter(4,  fCmpvB.first, fCmpvB.second);
  fMinuit->GetParameter(5,  fCmpvC.first, fCmpvC.second);
  fMinuit->GetParameter(6,  fCmpvD.first, fCmpvD.second);
  fMinuit->GetParameter(7,  fCmpvR.first, fCmpvR.second);
  fMinuit->GetParameter(8,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(9,  fCgwB.first,  fCgwB.second);
  fMinuit->GetParameter(10, fCgwC.first,  fCgwC.second);
  fMinuit->GetParameter(11, fCnorm.first, fCnorm.second);
  
  StoreCoherentFits(); 
}

//********************************************************************
void CoherentSample::fcnSignal(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwA  = par[0];
  double lwB  = par[1];
  double lwC  = par[2];
  double mpvA = par[3];
  double mpvB = par[4];
  double mpvC = par[5];
  double mpvD = par[6];
  double mpvR = par[7];
  double gwA  = par[8];
  double gwB  = par[9];
  double gwC  = par[10];
  double norm = par[11];
  
  //define function to fit to each histogram
  double lw,mpv,gw;//norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double lw_par[]  = {lwA,lwB,lwC,0};
    double mpv_par[] = {mpvA,mpvB,mpvC,mpvD,mpvR,0};
    double gw_par[]  = {gwA,gwB,gwC,0};
    double RR_par[]  = {CSMinuit->fRR[ibin].first};
 
    lw   = CoherentFitUtils::ABCParametrization(RR_par,lw_par);
    mpv  = CoherentFitUtils::ABCDRParametrization(RR_par,mpv_par);
    gw   = CoherentFitUtils::ABCParametrization(RR_par,gw_par);

    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//shift and widths as quadratic ABC addition to signal width
//shift and withs as cuadratic sums from signal widths
//********************************************************************
void CoherentSample::CoherentFitBackgroundQuadraticWidths(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 7+1;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackgroundQuadraticWidths);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {2.6,  4.60, -1.98, 0.063, 36.9, -2.01, 0.09};
  Double_t step[NPAR]   = {0.1,   0.1,   0.1,   0.1,  0.1,  0.01, 0.01};
  double mean_norm = 0;
  for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  mean_norm = mean_norm / fInorm.size();
  fMinuit->mnparm(0,  "shift", vstart[0], step[0],   0, 10, ierflg);
  fMinuit->mnparm(1,  "lwA"  , vstart[1], step[1],   0, 10, ierflg);
  fMinuit->mnparm(2,  "lwB"  , vstart[2], step[2], -10,  0, ierflg);
  fMinuit->mnparm(3,  "lwC"  , vstart[3], step[3],   0,  1, ierflg);
  fMinuit->mnparm(4,  "gwA"  , vstart[4], step[4],   0, 90, ierflg);
  fMinuit->mnparm(5,  "gwB"  , vstart[5], step[5], -10,  0, ierflg);
  fMinuit->mnparm(6,  "gwC"  , vstart[6], step[6],   0,  1, ierflg);
  fMinuit->mnparm(7,  "norm" , mean_norm, 0.01,      0,  1, ierflg);
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0, fCshift.first, fCshift.second);
  fMinuit->GetParameter(1, fClwA.first,   fClwA.second);
  fMinuit->GetParameter(2, fClwB.first,   fClwB.second);
  fMinuit->GetParameter(3, fClwC.first,   fClwC.second);
  fMinuit->GetParameter(4, fCgwA.first,   fCgwA.second);
  fMinuit->GetParameter(5, fCgwB.first,   fCgwB.second);
  fMinuit->GetParameter(6, fCgwC.first,   fCgwC.second);
  fMinuit->GetParameter(7, fCnorm.first,  fCnorm.second);

  fCmpvA = fTrueSignal->GetCmpvA();
  fCmpvB = fTrueSignal->GetCmpvB();
  fCmpvC = fTrueSignal->GetCmpvC();
  fCmpvD = fTrueSignal->GetCmpvD();
  fCmpvR = fTrueSignal->GetCmpvR();
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackgroundQuadraticWidths(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  //set each parameter
  double shift = par[0];
  double blwA  = par[1];
  double blwB  = par[2];
  double blwC  = par[3];
  double bgwA  = par[4];
  double bgwB  = par[5];
  double bgwC  = par[6];
  double norm  = par[7];
  double slwA  = CSMinuit->GetTrueSignal()->GetClwA().first;
  double slwB  = CSMinuit->GetTrueSignal()->GetClwB().first;
  double slwC  = CSMinuit->GetTrueSignal()->GetClwC().first;
  double smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;
  double smpvR = CSMinuit->GetTrueSignal()->GetCmpvR().first;
  double sgwA  = CSMinuit->GetTrueSignal()->GetCgwA().first;
  double sgwB  = CSMinuit->GetTrueSignal()->GetCgwB().first;
  double sgwC  = CSMinuit->GetTrueSignal()->GetCgwC().first;
  
  //define function to fit to each histogram
  double lw,mpv,gw;//norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double lw_par[]   = {slwA,slwB,slwC,blwA,blwB,blwC};
    double mpv_par[]  = {smpvA,smpvB,smpvC,smpvD,smpvR,shift};
    double gw_par[]   = {sgwA,sgwB,sgwC,bgwA,bgwB,bgwC};
    double RR_par[]   = {CSMinuit->fRR[ibin].first};
    lw   = CoherentFitUtils::QuadraticABCParametrization(RR_par,lw_par);
    mpv  = CoherentFitUtils::ABCDRParametrization(RR_par,mpv_par);
    gw   = CoherentFitUtils::QuadraticABCParametrization(RR_par,gw_par);
    //norm = par[CPAR+ibin];
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundQuadraticWidths(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 18+1;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundQuadraticWidths);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,smpvR,sgwA,sgwB,sgwC,blwA,blwB,blwC,bshift,bgwA,bgwB,bgwC,norm,slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,smpvR_error,sgwA_error,sgwB_error,sgwC_error,blwA_error,blwB_error,blwC_error,bshift_error,bgwA_error,bgwB_error,bgwC_error,norm_error;

  slwA   = GetSignal()->GetClwA().first;         
  slwB   = GetSignal()->GetClwB().first;	 
  slwC   = GetSignal()->GetClwC().first;	 
  smpvA  = GetSignal()->GetCmpvA().first;	 
  smpvB  = GetSignal()->GetCmpvB().first;	 
  smpvC  = GetSignal()->GetCmpvC().first;	 
  smpvD  = GetSignal()->GetCmpvD().first;	 
  smpvR  = GetSignal()->GetCmpvR().first;	 
  sgwA   = GetSignal()->GetCgwA().first;	 
  sgwB   = GetSignal()->GetCgwB().first;	 
  sgwC   = GetSignal()->GetCgwC().first;	 
  blwA   = GetBackground()->GetClwA().first;	 
  blwB   = GetBackground()->GetClwB().first;	 
  blwC   = GetBackground()->GetClwC().first;	 
  bshift = GetBackground()->GetCshift().first;   
  bgwA   = GetBackground()->GetCgwA().first;	 
  bgwB   = GetBackground()->GetCgwB().first;	 
  bgwC   = GetBackground()->GetCgwC().first;
  norm   = (GetSignal()->GetCnorm().first + (1-GetBackground()->GetCnorm().first))/2;
  
  Double_t vstart[NPAR] = {slwA, slwB, slwC, smpvA, smpvB, smpvC, smpvD, smpvR, sgwA, sgwB, sgwC,
			   blwA, blwB, blwC, bshift,                            bgwA, bgwB, bgwC,
                           norm};
  Double_t step[NPAR]   = {0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01};
  
  fMinuit->mnparm(0,  "s lw A" , vstart[0] ,  step[0],   0,  0, ierflg);
  fMinuit->mnparm(1,  "s lw B" , vstart[1] ,  step[1],   0,  0, ierflg);
  fMinuit->mnparm(2,  "s lw C" , vstart[2] ,  step[2],   0,  0, ierflg);
  fMinuit->mnparm(3,  "s mpv A", vstart[3] ,  step[3],   0,  0, ierflg);
  fMinuit->mnparm(4,  "s mpv B", vstart[4] ,  step[4],   0,  0, ierflg);
  fMinuit->mnparm(5,  "s mpv C", vstart[5] ,  step[5],   0,  0, ierflg);
  fMinuit->mnparm(6,  "s mpv D", vstart[6] ,  step[6],   0,  0, ierflg);
  fMinuit->mnparm(7,  "s mpv R", vstart[7] ,  step[7],   0,  0, ierflg);
  fMinuit->mnparm(8,  "s gw A" , vstart[8] ,  step[8],   0,  0, ierflg);
  fMinuit->mnparm(9,  "s gw B" , vstart[9] ,  step[9],   0,  0, ierflg);
  fMinuit->mnparm(10, "s gw C" , vstart[10], step[10],   0,  0, ierflg);
  fMinuit->mnparm(11, "b lw A" , vstart[11], step[11],   0, 10, ierflg);
  fMinuit->mnparm(12, "b lw B" , vstart[12], step[12], -10,  0, ierflg);
  fMinuit->mnparm(13, "b lw C" , vstart[13], step[13],   0, 10, ierflg);
  fMinuit->mnparm(14, "b shift", vstart[14], step[14],   0,  0, ierflg);
  fMinuit->mnparm(15, "b gw A" , vstart[15], step[15],   0, 90, ierflg);
  fMinuit->mnparm(16, "b gw B" , vstart[16], step[16], -10,  0, ierflg);
  fMinuit->mnparm(17, "b gw C" , vstart[17], step[17],   0, 10, ierflg);
  fMinuit->mnparm(18, "norm"   , vstart[18], step[18], 0.95*vstart[18], 1.05*vstart[18], ierflg);
  
  fMinuit->FixParameter(13);
  fMinuit->FixParameter(17);
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  slwA  , slwA_error);
  fMinuit->GetParameter(1,  slwB  , slwB_error);
  fMinuit->GetParameter(2,  slwC  , slwC_error);
  fMinuit->GetParameter(3,  smpvA , smpvA_error);
  fMinuit->GetParameter(4,  smpvB , smpvB_error);
  fMinuit->GetParameter(5,  smpvC , smpvC_error);
  fMinuit->GetParameter(6,  smpvD , smpvD_error);
  fMinuit->GetParameter(7,  smpvR , smpvR_error);
  fMinuit->GetParameter(8,  sgwA  , sgwA_error);
  fMinuit->GetParameter(9,  sgwB  , sgwB_error);
  fMinuit->GetParameter(10, sgwC  , sgwC_error);
  fMinuit->GetParameter(11, blwA  , blwA_error);
  fMinuit->GetParameter(12, blwB  , blwB_error);
  fMinuit->GetParameter(13, blwC  , blwC_error);
  fMinuit->GetParameter(14, bshift, bshift_error);
  fMinuit->GetParameter(15, bgwA  , bgwA_error);
  fMinuit->GetParameter(16, bgwB  , bgwB_error);
  fMinuit->GetParameter(17, bgwC  , bgwC_error);
  fMinuit->GetParameter(18, norm  , norm_error);

  GetSignal()->SetClwA(std::make_pair(slwA,slwA_error));
  GetSignal()->SetClwB(std::make_pair(slwB,slwB_error));
  GetSignal()->SetClwC(std::make_pair(slwC,slwC_error));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,smpvR_error));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,smpvC_error));
  GetSignal()->SetCmpvR(std::make_pair(smpvR,smpvD_error));
  GetSignal()->SetCgwA(std::make_pair(sgwA,sgwA_error));
  GetSignal()->SetCgwB(std::make_pair(sgwB,sgwB_error));
  GetSignal()->SetCgwC(std::make_pair(sgwC,sgwC_error));
  GetSignal()->SetCnorm(std::make_pair(norm,norm_error));

  GetBackground()->SetClwA(std::make_pair(blwA,blwA_error));
  GetBackground()->SetClwB(std::make_pair(blwB,blwB_error));
  GetBackground()->SetClwC(std::make_pair(blwC,blwC_error));
  GetBackground()->SetCmpvA(GetSignal()->GetCmpvA());
  GetBackground()->SetCmpvB(GetSignal()->GetCmpvB());
  GetBackground()->SetCmpvC(GetSignal()->GetCmpvC());
  GetBackground()->SetCmpvD(GetSignal()->GetCmpvD());
  GetBackground()->SetCmpvR(GetSignal()->GetCmpvR());
  GetBackground()->SetCshift(std::make_pair(bshift,bshift_error));
  GetBackground()->SetCgwA(std::make_pair(bgwA,bgwA_error));
  GetBackground()->SetCgwB(std::make_pair(bgwB,bgwB_error));
  GetBackground()->SetCgwC(std::make_pair(bgwC,bgwC_error));
  GetBackground()->SetCnorm(std::make_pair(1-norm,norm_error));
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundQuadraticWidths(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  const int NBINS = CSMinuit->fh.size();
  
  //set each parameter
  double slwA  = par[0];
  double slwB  = par[1];
  double slwC  = par[2];
  double smpvA = par[3];
  double smpvB = par[4];
  double smpvC = par[5];
  double smpvD = par[6];
  double smpvR = par[7];
  double sgwA  = par[8];
  double sgwB  = par[9];
  double sgwC  = par[10];
  double blwA  = par[11];
  double blwB  = par[12];
  double blwC  = par[13];
  double shift = par[14];
  double bgwA  = par[15];
  double bgwB  = par[16];
  double bgwC  = par[17];
  double norm  = par[18];
  
  //define function to fit to each histogram
  double slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw;
  //std::vector<double> vnorm;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < NBINS; ibin++){
    //get RR depending parameters
    double slw_par[]  = {slwA,slwB,slwC,0};
    double smpv_par[] = {smpvA,smpvB,smpvC,smpvD,smpvR,0};
    double sgw_par[]  = {sgwA,sgwB,sgwC,0};
    double blw_par[]  = {slwA,slwB,slwC,blwA,blwB,blwC};
    double bmpv_par[] = {smpvA,smpvB,smpvC,smpvD,smpvR,shift};
    double bgw_par[]  = {sgwA,sgwB,sgwC,bgwA,bgwB,bgwC};
    double RR_par[]   = {CSMinuit->fRR[ibin].first};
    
    slw   = CoherentFitUtils::ABCParametrization(RR_par,slw_par);
    smpv  = CoherentFitUtils::ABCDRParametrization(RR_par,smpv_par);
    sgw   = CoherentFitUtils::ABCParametrization(RR_par,sgw_par);
    snorm = norm;
    blw   = CoherentFitUtils::QuadraticABCParametrization(RR_par,blw_par);
    bmpv  = CoherentFitUtils::ABCDRParametrization(RR_par,bmpv_par);
    bgw   = CoherentFitUtils::QuadraticABCParametrization(RR_par,bgw_par);
    bnorm = 1-norm;

    flg->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }

  f = -Likelihood;
}

//Chebyshev polynomials models
//********************************************************************
void CoherentSample::CoherentFitSignalCheb(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 11+1;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalCheb);

  Double_t arglist[10];
  Int_t ierflg = 0;

  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //Set starting values and step sizes for parameters
  //double mean_norm = 0;
  //for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  //mean_norm = mean_norm / fInorm.size();
 
  fMinuit->mnparm(0,  "lw A" , 3.29  , 100, 0, 0, ierflg);//0.9*3.29  , 1.1*3.29  , ierflg);//
  fMinuit->mnparm(1,  "lw B" , -4.57 , 100, 0, 0, ierflg);//0.9*-4.57 , 1.1*-4.57 , ierflg);//
  fMinuit->mnparm(2,  "lw C" , 1.42  , 100, 0, 0, ierflg);//0.9*1.42  , 1.1*1.42  , ierflg);//
  fMinuit->mnparm(3,  "mpv A", 0.65  , 100, 0, 0, ierflg);//0.9*0.65  , 1.1*0.65  , ierflg);//
  fMinuit->mnparm(4,  "mpv B", 9.48  , 100, 0, 0, ierflg);//0.9*9.48  , 1.1*9.48  , ierflg);//
  fMinuit->mnparm(5,  "mpv C", -11.50, 100, 0, 0, ierflg);//0.9*-11.50, 1.1*-11.50, ierflg);//
  fMinuit->mnparm(6,  "mpv D", 5.20  , 100, 0, 0, ierflg);//0.9*5.20  , 1.1*5.20  , ierflg);//
  fMinuit->mnparm(7,  "mpv R", -2.10 , 100, 0, 0, ierflg);//0.9*-2.10 , 1.1*-2.10 , ierflg);//
  fMinuit->mnparm(8,  "gw A" , 2.34  , 100, 0, 0, ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(9,  "gw B" , -2.33 , 100, 0, 0, ierflg);//0.9*-2.18 , 1.1*-2.18 , ierflg);//
  fMinuit->mnparm(10, "gw C" , 0.0   , 100, 0, 0, ierflg);//0.9*0.05  , 1.1*-0.05 , ierflg);//
  fMinuit->mnparm(11, "norm" , 0.88  , 100, 0, 0, ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//
  fMinuit->FixParameter(10);
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
 
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(1,  fClwB.first,  fClwB.second);
  fMinuit->GetParameter(2,  fClwC.first,  fClwC.second);
  fMinuit->GetParameter(3,  fCmpvA.first, fCmpvA.second);
  fMinuit->GetParameter(4,  fCmpvB.first, fCmpvB.second);
  fMinuit->GetParameter(5,  fCmpvC.first, fCmpvC.second);
  fMinuit->GetParameter(6,  fCmpvD.first, fCmpvD.second);
  fMinuit->GetParameter(7,  fCmpvR.first, fCmpvR.second);
  fMinuit->GetParameter(8,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(9,  fCgwB.first,  fCgwB.second);
  fMinuit->GetParameter(10, fCgwC.first,  fCgwC.second);
  fMinuit->GetParameter(11, fCnorm.first, fCnorm.second);
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalCheb(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwA  = par[0];
  double lwB  = par[1];
  double lwC  = par[2];
  double mpvA = par[3];
  double mpvB = par[4];
  double mpvC = par[5];
  double mpvD = par[6];
  double mpvR = par[7];
  double gwA  = par[8];
  double gwB  = par[9];
  double gwC  = par[10];
  double norm = par[11];

  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x = (CSMinuit->fRR[ibin].first-1)/(CSMinuit->fRR[ibin].first+1);
    lw   = ROOT::Math::Chebyshev2(x,lwA,lwB,lwC);
    mpv  = ROOT::Math::Chebyshev4(x,mpvA,mpvB,mpvC,mpvD,mpvR);
    gw   = ROOT::Math::Chebyshev2(x,gwA,gwB,gwC);
    flg->SetParameters(lw,mpv,norm,gw);
    /*if(ibin==0){
      CSMinuit->fh[ibin]->Draw();
      flg->Draw("same");
      gPad->Update();
      }*/
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitBackgroundCheb(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 2+1;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackgroundCheb);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  fMinuit->mnparm(0, "shift_l" , -1.11, 10, 0, 0, ierflg);//-1.5
  fMinuit->mnparm(1, "shift_m" , 3.78 , 10,  0, 0, ierflg);
  //fMinuit->mnparm(2, "shift_g" , -1.5 , 10, -3, 0, ierflg);
  //fMinuit->mnparm(2, "gwA"     , -8.8 , 10,  0, 0, ierflg);
  //fMinuit->mnparm(3, "gwB"     , 14   , 10,  0, 0, ierflg);
  //fMinuit->mnparm(4, "gwV"     , -5.5 , 10,  0, 0, ierflg);
  //fMinuit->mnparm(0, "shift_l" , 2, 10, -5, 5, ierflg);//-1.5
  fMinuit->mnparm(2, "norm"    , 0.13 , 10,  0, 1, ierflg);
  //fMinuit->FixParameter(0);
  //fMinuit->FixParameter(2);
  //fMinuit->FixParameter(3);
  //fMinuit->FixParameter(4);
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0, fClwA.first,   fClwA.second);
  fMinuit->GetParameter(1, fCshift.first, fCshift.second);
  //fMinuit->GetParameter(2, fCgwA.first,   fCgwA.second);
  //fMinuit->GetParameter(3, fCgwB.first,   fCgwB.second);
  //fMinuit->GetParameter(4, fCgwC.first,   fCgwC.second);
  fMinuit->GetParameter(2, fCnorm.first,  fCnorm.second);

  fCmpvA = fTrueSignal->GetCmpvA();
  fCmpvB = fTrueSignal->GetCmpvB();
  fCmpvC = fTrueSignal->GetCmpvC();
  fCmpvD = fTrueSignal->GetCmpvD();
  fCmpvR = fTrueSignal->GetCmpvR();
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackgroundCheb(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  //set each parameter
  double shift_l = par[0];
  double shift_m = par[1];
  //double shift_g = par[2];
  //double gwA     = par[2];
  //double gwB     = par[3];
  //double gwC     = par[4];
  double norm  = par[2];
  double slwA  = CSMinuit->GetTrueSignal()->GetClwA().first;
  double slwB  = CSMinuit->GetTrueSignal()->GetClwB().first;
  double slwC  = CSMinuit->GetTrueSignal()->GetClwC().first;
  double smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;
  double smpvR = CSMinuit->GetTrueSignal()->GetCmpvR().first;
  double sgwA  = CSMinuit->GetTrueSignal()->GetCgwA().first;
  double sgwB  = CSMinuit->GetTrueSignal()->GetCgwB().first;
  double sgwC  = CSMinuit->GetTrueSignal()->GetCgwC().first;

  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    //double x   = (CSMinuit->fRR[ibin].first-1        )/(CSMinuit->fRR[ibin].first+1        );
    double x_l = (CSMinuit->fRR[ibin].first-1+shift_l)/(CSMinuit->fRR[ibin].first+1+shift_l);
    double x_m = (CSMinuit->fRR[ibin].first-1+shift_m)/(CSMinuit->fRR[ibin].first+1+shift_m);
    //double x_g = (CSMinuit->fRR[ibin].first-1+shift_g)/(CSMinuit->fRR[ibin].first+1+shift_g);
    lw   = ROOT::Math::Chebyshev2(x_l,slwA,slwB,slwC);
    mpv  = ROOT::Math::Chebyshev4(x_m,smpvA,smpvB,smpvC,smpvD,smpvR);
    gw   = ROOT::Math::Chebyshev2(x_l,sgwA,sgwB,sgwC);
    //gw   = ROOT::Math::Chebyshev2(x,gwA,gwB,gwC);
    //norm = par[CPAR+ibin];
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundCheb(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 13+1;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundCheb);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //initial par
  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,smpvR,sgwA,sgwB,sgwC,bshift_l,bshift_m,bshift_g,norm,slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,smpvR_error,sgwA_error,sgwB_error,sgwC_error,bshift_l_error,bshift_m_error,bshift_g_error,norm_error;

  slwA     = GetSignal()->GetClwA().first;         
  slwB     = GetSignal()->GetClwB().first;	 
  slwC     = GetSignal()->GetClwC().first;	 
  smpvA    = GetSignal()->GetCmpvA().first;	 
  smpvB    = GetSignal()->GetCmpvB().first;	 
  smpvC    = GetSignal()->GetCmpvC().first;	 
  smpvD    = GetSignal()->GetCmpvD().first;	 
  smpvR    = GetSignal()->GetCmpvR().first;	 
  sgwA     = GetSignal()->GetCgwA().first;	 
  sgwB     = GetSignal()->GetCgwB().first;	 
  sgwC     = GetSignal()->GetCgwC().first;	 
  bshift_l = GetBackground()->GetClwA().first;	 
  bshift_m = GetBackground()->GetCshift().first;   
  //bshift_g = GetBackground()->GetCgwA().first;	 
  norm     = (GetSignal()->GetCnorm().first + (1-GetBackground()->GetCnorm().first))/2;
  
  fMinuit->mnparm(0,  "lw A"    , slwA    , 100, 0, 0, ierflg);//0.9*3.29  , 1.1*3.29  , ierflg);//
  fMinuit->mnparm(1,  "lw B"    , slwB    , 100, 0, 0, ierflg);//0.9*-4.57 , 1.1*-4.57 , ierflg);//
  fMinuit->mnparm(2,  "lw C"    , slwC    , 100, 0, 0, ierflg);//0.9*1.42  , 1.1*1.42  , ierflg);//
  fMinuit->mnparm(3,  "mpv A"   , smpvA   , 100, 0, 0, ierflg);//0.9*0.65  , 1.1*0.65  , ierflg);//
  fMinuit->mnparm(4,  "mpv B"   , smpvB   , 100, 0, 0, ierflg);//0.9*9.48  , 1.1*9.48  , ierflg);//
  fMinuit->mnparm(5,  "mpv C"   , smpvC   , 100, 0, 0, ierflg);//0.9*-11.50, 1.1*-11.50, ierflg);//
  fMinuit->mnparm(6,  "mpv D"   , smpvD   , 100, 0, 0, ierflg);//0.9*5.20  , 1.1*5.20  , ierflg);//
  fMinuit->mnparm(7,  "mpv R"   , smpvR   , 100, 0, 0, ierflg);//0.9*-2.10 , 1.1*-2.10 , ierflg);//
  fMinuit->mnparm(8,  "gw A"    , sgwA    , 100, 0, 0, ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(9,  "gw B"    , sgwB    , 100, 0, 0, ierflg);//0.9*-2.18 , 1.1*-2.18 , ierflg);//
  fMinuit->mnparm(10, "gw C"    , sgwC    , 100, 0, 0, ierflg);//0.9*0.05  , 1.1*-0.05 , ierflg);//
  fMinuit->mnparm(11, "bshift_l", bshift_l, 100, 0, 0, ierflg);//-1.5
  fMinuit->mnparm(12, "bshift_m", bshift_m, 100, 0, 0, ierflg);
  //fMinuit->mnparm(13, "bshift_g", bshift_g, 100, -5, 0, ierflg);
  fMinuit->mnparm(13, "norm"    , norm    , 100, 0, 1, ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//
  fMinuit->FixParameter(10);
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  slwA     , slwA_error);
  fMinuit->GetParameter(1,  slwB     , slwB_error);
  fMinuit->GetParameter(2,  slwC     , slwC_error);
  fMinuit->GetParameter(3,  smpvA    , smpvA_error);
  fMinuit->GetParameter(4,  smpvB    , smpvB_error);
  fMinuit->GetParameter(5,  smpvC    , smpvC_error);
  fMinuit->GetParameter(6,  smpvD    , smpvD_error);
  fMinuit->GetParameter(7,  smpvR    , smpvR_error);
  fMinuit->GetParameter(8,  sgwA     , sgwA_error);
  fMinuit->GetParameter(9,  sgwB     , sgwB_error);
  fMinuit->GetParameter(10, sgwC     , sgwC_error);
  fMinuit->GetParameter(11, bshift_l , bshift_l_error);
  fMinuit->GetParameter(12, bshift_m , bshift_m_error);
  //fMinuit->GetParameter(13, bshift_g , bshift_g_error);
  fMinuit->GetParameter(13, norm     , norm_error);

  GetSignal()->SetClwA(std::make_pair(slwA,slwA_error));
  GetSignal()->SetClwB(std::make_pair(slwB,slwB_error));
  GetSignal()->SetClwC(std::make_pair(slwC,slwC_error));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,smpvR_error));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,smpvC_error));
  GetSignal()->SetCmpvR(std::make_pair(smpvR,smpvD_error));
  GetSignal()->SetCgwA(std::make_pair(sgwA,sgwA_error));
  GetSignal()->SetCgwB(std::make_pair(sgwB,sgwB_error));
  GetSignal()->SetCgwC(std::make_pair(sgwC,sgwC_error));
  GetSignal()->SetCnorm(std::make_pair(norm,norm_error));

  GetBackground()->SetClwA(std::make_pair(bshift_l,bshift_l_error));
  GetBackground()->SetCmpvA(GetSignal()->GetCmpvA());
  GetBackground()->SetCmpvB(GetSignal()->GetCmpvB());
  GetBackground()->SetCmpvC(GetSignal()->GetCmpvC());
  GetBackground()->SetCmpvD(GetSignal()->GetCmpvD());
  GetBackground()->SetCmpvR(GetSignal()->GetCmpvR());
  GetBackground()->SetCshift(std::make_pair(bshift_m,bshift_m_error));
  GetBackground()->SetCgwA(std::make_pair(bshift_l,bshift_l_error));
  GetBackground()->SetCnorm(std::make_pair(1-norm,norm_error));
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundCheb(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  //set each parameter
  double lwA     = par[0];
  double lwB     = par[1];
  double lwC     = par[2];
  double mpvA    = par[3];
  double mpvB    = par[4];
  double mpvC    = par[5];
  double mpvD    = par[6];
  double mpvR    = par[7];
  double gwA     = par[8];
  double gwB     = par[9];
  double gwC     = par[10];
  double shift_l = par[11];
  double shift_m = par[12];
  //double shift_g = par[13];
  double norm    = par[13];

  //define function to fit to each histogram
  double slw,smpv,sgw,snorm,blw,bmpv,bgw,bnorm;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = (CSMinuit->fRR[ibin].first-1        )/(CSMinuit->fRR[ibin].first+1        );
    double x_l = (CSMinuit->fRR[ibin].first-1+shift_l)/(CSMinuit->fRR[ibin].first+1+shift_l);
    double x_m = (CSMinuit->fRR[ibin].first-1+shift_m)/(CSMinuit->fRR[ibin].first+1+shift_m);
    //double x_g = (CSMinuit->fRR[ibin].first-1+shift_g)/(CSMinuit->fRR[ibin].first+1+shift_g);
    slw   = ROOT::Math::Chebyshev2(x  ,lwA ,lwB ,lwC);
    smpv  = ROOT::Math::Chebyshev4(x  ,mpvA,mpvB,mpvC,mpvD,mpvR);
    sgw   = ROOT::Math::Chebyshev2(x  ,gwA ,gwB ,gwC);
    snorm = norm;
    blw   = ROOT::Math::Chebyshev2(x_l,lwA ,lwB ,lwC);
    bmpv  = ROOT::Math::Chebyshev4(x_m,mpvA,mpvB,mpvC,mpvD,mpvR);
    bgw   = ROOT::Math::Chebyshev2(x_l,gwA ,gwB ,gwC);
    bnorm = 1-norm;

    //    std::cout << slw << " " << smpv << " " << sgw << " " << blw << " " << bmpv << " " << bgw << std::endl;
    
    flg->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//laguerre polynomials models
//********************************************************************
void CoherentSample::CoherentFitSignalLag(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 10;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalLag);

  Double_t arglist[10];
  Int_t ierflg = 0;

  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //Set starting values and step sizes for parameters
  double mean_norm = 0;
  for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  mean_norm = 0.88;//mean_norm / fInorm.size();
 
  fMinuit->mnparm(0,  "lw A" , 2.9  , 1, 0, 0, ierflg);//0.9*3.29  , 1.1*3.29  , ierflg);//
  fMinuit->mnparm(1,  "lw B" , -6.6 , 1, 0, 0, ierflg);//0.9*-4.57 , 1.1*-4.57 , ierflg);//
  fMinuit->mnparm(2,  "lw C" , 5.5  , 1, 0, 0, ierflg);//0.9*1.42  , 1.1*1.42  , ierflg);//
  fMinuit->mnparm(3,  "mpv A", -67  , 1, 0, 0, ierflg);//0.9*0.65  , 1.1*0.65  , ierflg);//
  fMinuit->mnparm(4,  "mpv B", 254  , 1, 0, 0, ierflg);//0.9*9.48  , 1.1*9.48  , ierflg);//
  fMinuit->mnparm(5,  "mpv C", -290 , 1, 0, 0, ierflg);//0.9*-11.50, 1.1*-11.50, ierflg);//
  fMinuit->mnparm(6,  "mpv D", 115  , 1, 0, 0, ierflg);//0.9*5.20  , 1.1*5.20  , ierflg);//
  fMinuit->mnparm(7,  "gw A" , 0.07 , 1, 0, 0, ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(8,  "gw B" , 2.17 , 1, 0, 0, ierflg);//0.9*-2.18 , 1.1*-2.18 , ierflg);//
  fMinuit->mnparm(9,  "norm" , mean_norm , 1, 0, 0, ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//
    
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
 
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(1,  fClwB.first,  fClwB.second);
  fMinuit->GetParameter(2,  fClwC.first,  fClwC.second);
  fMinuit->GetParameter(3,  fCmpvA.first, fCmpvA.second);
  fMinuit->GetParameter(4,  fCmpvB.first, fCmpvB.second);
  fMinuit->GetParameter(5,  fCmpvC.first, fCmpvC.second);
  fMinuit->GetParameter(6,  fCmpvD.first, fCmpvD.second);
  fMinuit->GetParameter(7,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(8,  fCgwB.first,  fCgwB.second);
  fMinuit->GetParameter(9, fCnorm.first, fCnorm.second);
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalLag(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwA  = par[0];
  double lwB  = par[1];
  double lwC  = par[2];
  double mpvA = par[3];
  double mpvB = par[4];
  double mpvC = par[5];
  double mpvD = par[6];
  double gwA  = par[7];
  double gwB  = par[8];
  double norm = par[9];

  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x = (CSMinuit->fRR[ibin].first-1)/(CSMinuit->fRR[ibin].first+1);
    lw   = lwA*ROOT::Math::laguerre(0,x) +lwB*ROOT::Math::laguerre(1,x) +lwC*ROOT::Math::laguerre(2,x);
    mpv  = mpvA*ROOT::Math::laguerre(0,x)+mpvB*ROOT::Math::laguerre(1,x)+mpvC*ROOT::Math::laguerre(2,x)+mpvD*ROOT::Math::laguerre(3,x);
    gw   = gwA*ROOT::Math::laguerre(0,x) +gwB*ROOT::Math::laguerre(1,x);
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitBackgroundLag(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 8;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackgroundLag);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  fMinuit->mnparm(0,  "lw A" , 3.9 , 1, 0, 0, ierflg);//0.9*3.29  , 1.1*3.29  , ierflg);//      3.9 
  fMinuit->mnparm(1,  "lw B" , -8.2 , 1, 0, 0, ierflg);//0.9*-4.57 , 1.1*-4.57 , ierflg);//	     -8.2
  fMinuit->mnparm(2,  "lw C" ,  7.6, 1, 0, 0, ierflg);//0.9*1.42  , 1.1*1.42  , ierflg);//	     7.6 
  fMinuit->mnparm(3,  "mpv S", 4.3  , 1, 0, 0, ierflg);//0.9*0.65  , 1.1*0.65  , ierflg);//
  fMinuit->mnparm(4,  "gw A" , -8.5 , 1, 0, 0, ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//      0.14
  fMinuit->mnparm(5,  "gw B" , 23.4 , 1, 0, 0, ierflg);//0.9*-2.18 , 1.1*-2.18 , ierflg);//	     2.35
  fMinuit->mnparm(6,  "gw C" , -16.6 , 1, 0, 0, ierflg);//0.9*-2.18 , 1.1*-2.18 , ierflg);//	     1.  
  fMinuit->mnparm(7,  "norm" , 0.1  , 1, 0, 0, ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//

  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0, fClwA.first,   fClwA.second);
  fMinuit->GetParameter(1, fClwB.first,   fClwB.second);
  fMinuit->GetParameter(2, fClwC.first,   fClwC.second);
  fMinuit->GetParameter(3, fCshift.first, fCshift.second);
  fMinuit->GetParameter(4, fCgwA.first,   fCgwA.second);
  fMinuit->GetParameter(5, fCgwB.first,   fCgwB.second);
  fMinuit->GetParameter(6, fCgwC.first,   fCgwC.second);
  fMinuit->GetParameter(7, fCnorm.first,  fCnorm.second);

  fCmpvA = fTrueSignal->GetCmpvA();
  fCmpvB = fTrueSignal->GetCmpvB();
  fCmpvC = fTrueSignal->GetCmpvC();
  fCmpvD = fTrueSignal->GetCmpvD();
  fCmpvR = fTrueSignal->GetCmpvR();

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackgroundLag(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  //set each parameter
  double lwA   = par[0];
  double lwB   = par[1];
  double lwC   = par[2];
  double shift = par[3];
  double gwA   = par[4];
  double gwB   = par[5];
  double gwC   = par[6];
  double norm  = par[7];

  // double slwA = CSMinuit->GetTrueSignal()->GetClwA().first;
  // double slwB = CSMinuit->GetTrueSignal()->GetClwB().first;
  // double slwC = CSMinuit->GetTrueSignal()->GetClwC().first;
  
  double smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;
  
  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = (CSMinuit->fRR[ibin].first-1)/(CSMinuit->fRR[ibin].first+1);
    //double x_lw = (CSMinuit->fRR[ibin].first-1+lwA)/(CSMinuit->fRR[ibin].first+1+lwA);
    double x_mpv = (CSMinuit->fRR[ibin].first-1+shift)/(CSMinuit->fRR[ibin].first+1+shift);
    //lw   = sqrt(pow(slwA*ROOT::Math::laguerre(0,x_lw) +slwB*ROOT::Math::laguerre(1,x_lw) +slwC*ROOT::Math::laguerre(2,x_lw),2)+pow(lwB,2));
    lw   = lwA*ROOT::Math::laguerre(0,x) +lwB*ROOT::Math::laguerre(1,x) +lwC*ROOT::Math::laguerre(2,x);
    mpv  = smpvA*ROOT::Math::laguerre(0,x_mpv)+smpvB*ROOT::Math::laguerre(1,x_mpv)+smpvC*ROOT::Math::laguerre(2,x_mpv)+smpvD*ROOT::Math::laguerre(3,x_mpv);
    gw   = gwA*ROOT::Math::laguerre(0,x) +gwB*ROOT::Math::laguerre(1,x) +gwC*ROOT::Math::laguerre(2,x);
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundLag(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 17;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundLag);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //initial par
  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,sgwA,sgwB,norm;
  double slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,sgwA_error,sgwB_error, norm_error;
  double blwA,blwB,blwC,bmpvS,bgwA,bgwB,bgwC;
  double blwA_error,blwB_error,blwC_error,bmpvS_error,bgwA_error,bgwB_error,bgwC_error;

  slwA = CSMinuit->GetTrueSignal()->GetClwA().first;
  slwB = CSMinuit->GetTrueSignal()->GetClwB().first;
  slwC = CSMinuit->GetTrueSignal()->GetClwC().first;

  smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;

  sgwA = CSMinuit->GetTrueSignal()->GetCgwA().first;
  sgwB = CSMinuit->GetTrueSignal()->GetCgwB().first;

  blwA = CSMinuit->GetTrueBackground()->GetClwA().first;
  blwB = CSMinuit->GetTrueBackground()->GetClwB().first;
  blwC = CSMinuit->GetTrueBackground()->GetClwC().first;

  bmpvS = CSMinuit->GetTrueBackground()->GetCshift().first;

  bgwA = CSMinuit->GetTrueBackground()->GetCgwA().first;
  bgwB = CSMinuit->GetTrueBackground()->GetCgwB().first;
  bgwC = CSMinuit->GetTrueBackground()->GetCgwC().first;

  norm = 1-CSMinuit->GetTrueBackground()->GetCnorm().first;

  slwA_error = CSMinuit->GetTrueSignal()->GetClwA().second;
  slwB_error = CSMinuit->GetTrueSignal()->GetClwB().second;
  slwC_error = CSMinuit->GetTrueSignal()->GetClwC().second;
      
  smpvA_error = CSMinuit->GetTrueSignal()->GetCmpvA().second;
  smpvB_error = CSMinuit->GetTrueSignal()->GetCmpvB().second;
  smpvC_error = CSMinuit->GetTrueSignal()->GetCmpvC().second;
  smpvD_error = CSMinuit->GetTrueSignal()->GetCmpvD().second;
      
  sgwA_error = CSMinuit->GetTrueSignal()->GetCgwA().second;
  sgwB_error = CSMinuit->GetTrueSignal()->GetCgwB().second;
      
  blwA_error = CSMinuit->GetTrueBackground()->GetClwA().second;
  blwB_error = CSMinuit->GetTrueBackground()->GetClwB().second;
  blwC_error = CSMinuit->GetTrueBackground()->GetClwC().second;
      
  bmpvS_error = CSMinuit->GetTrueBackground()->GetCshift().second;
      
  bgwA_error = CSMinuit->GetTrueBackground()->GetCgwA().second;
  bgwB_error = CSMinuit->GetTrueBackground()->GetCgwB().second;
  bgwC_error = CSMinuit->GetTrueBackground()->GetCgwC().second;

  norm_error = 1-CSMinuit->GetTrueBackground()->GetCnorm().second;
  
  fMinuit->mnparm(0,  "lw A"      , slwA  , 10*slwA_error  , 0, 0, ierflg);  // 2.73938e+00 
  fMinuit->mnparm(1,  "lw B"      , slwB  , 10*slwB_error  , 0, 0, ierflg);  //-6.30265e+00
  fMinuit->mnparm(2,  "lw C"      , slwC  , 10*slwC_error  , 0, 0, ierflg);  // 5.22968e+00
  fMinuit->mnparm(3,  "mpv A"     , smpvA , 10*smpvA_error , 0, 0, ierflg);  //-7.80112e+01
  fMinuit->mnparm(4,  "mpv B"     , smpvB , 10*smpvB_error , 0, 0, ierflg);  // 2.95159e+02
  fMinuit->mnparm(5,  "mpv C"     , smpvC , 10*smpvC_error , 0, 0, ierflg);  //-3.41434e+02
  fMinuit->mnparm(6,  "mpv D"     , smpvD , 10*smpvD_error , 0, 0, ierflg);  // 1.36370e+02
  fMinuit->mnparm(7,  "gw A"      , sgwA  , 10*sgwA_error  , 0, 0, ierflg);  // 7.61715e-02
  fMinuit->mnparm(8,  "gw B"      , sgwB  , 10*sgwB_error  , 0, 0, ierflg);  // 2.02543e+00
  fMinuit->mnparm(9,  "blw A"     , blwA  , 10*blwA_error  , 0, 0, ierflg);  // 5.96330e-01
  fMinuit->mnparm(10, "blw B"     , blwB  , 10*blwB_error  , 0, 0, ierflg);  // 4.02872e-02
  fMinuit->mnparm(11, "blw C"     , blwC  , 10*blwC_error  , 0, 0, ierflg);  // 4.02872e-02
  fMinuit->mnparm(12, "mpv shift" , bmpvS , 10*bmpvS_error , 0.9*bmpvS, 1.1*bmpvS, ierflg);  // 3.14637e+00
  fMinuit->mnparm(13,  "bgw A"    , bgwA  , 10*bgwA_error  , 0, 0, ierflg);  // 4.21610e+00
  fMinuit->mnparm(14,  "bgw B"    , bgwB  , 10*bgwB_error  , 0, 0, ierflg);  //-5.62652e+00
  fMinuit->mnparm(15,  "bgw C"    , bgwC  , 10*bgwC_error  , 0, 0, ierflg);  // 8.24227e+00
  fMinuit->mnparm(16, "norm"      , norm  , 10*norm_error  , 0.9*norm, 1.1*norm, ierflg);// 8.74262e-01

  // fMinuit->FixParameter(0);
  // fMinuit->FixParameter(1);
  // fMinuit->FixParameter(2);
  // fMinuit->FixParameter(3);
  // fMinuit->FixParameter(4);
  // fMinuit->FixParameter(5);
  // fMinuit->FixParameter(6);
  // fMinuit->FixParameter(7);
  // fMinuit->FixParameter(8);
  // // fMinuit->FixParameter(9);
  // // fMinuit->FixParameter(10);
  // // fMinuit->FixParameter(11);
  // // fMinuit->FixParameter(12);
  // // fMinuit->FixParameter(13);
  // // fMinuit->FixParameter(14);    
  // // fMinuit->FixParameter(15);
  // fMinuit->FixParameter(16); 

  // Set strategy to 2, we want TMinuit to try its best
  arglist[0] = 2;
  fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  
  // // Now ready for minimization step
  // arglist[0] = 50000;
  // arglist[1] = 1.;
  // fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  //first fit exclusively norm and shift
  // fMinuit->FixParameter(0); 
  // fMinuit->FixParameter(1); 
  // fMinuit->FixParameter(2); 
  // fMinuit->FixParameter(3); 
  // fMinuit->FixParameter(4); 
  // fMinuit->FixParameter(5); 
  // fMinuit->FixParameter(6); 
  // fMinuit->FixParameter(7); 
  // fMinuit->FixParameter(8); 
  // fMinuit->FixParameter(9); 
  // fMinuit->FixParameter(10);
  // fMinuit->FixParameter(11);
  // fMinuit->FixParameter(12);
  // fMinuit->FixParameter(13);
  // fMinuit->FixParameter(14);
  // fMinuit->FixParameter(15);
  // fMinuit->FixParameter(16);
      
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);

  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  slwA  , slwA_error);
  fMinuit->GetParameter(1,  slwB  , slwB_error);
  fMinuit->GetParameter(2,  slwC  , slwC_error);
  fMinuit->GetParameter(3,  smpvA , smpvA_error);
  fMinuit->GetParameter(4,  smpvB , smpvB_error);
  fMinuit->GetParameter(5,  smpvC , smpvC_error);
  fMinuit->GetParameter(6,  smpvD , smpvD_error);
  fMinuit->GetParameter(7,  sgwA  , sgwA_error);
  fMinuit->GetParameter(8,  sgwB  , sgwB_error);
  fMinuit->GetParameter(9,  blwA  , blwA_error);
  fMinuit->GetParameter(10, blwB  , blwB_error);
  fMinuit->GetParameter(11, blwC  , blwC_error);
  fMinuit->GetParameter(12, bmpvS , bmpvS_error);
  fMinuit->GetParameter(13, bgwA  , bgwA_error);
  fMinuit->GetParameter(14, bgwB  , bgwB_error);
  fMinuit->GetParameter(15, bgwC  , bgwC_error);
  fMinuit->GetParameter(16, norm  , norm_error);

  GetSignal()->SetClwA(std::make_pair(slwA,slwA_error));
  GetSignal()->SetClwB(std::make_pair(slwB,slwB_error));
  GetSignal()->SetClwC(std::make_pair(slwC,slwC_error));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,smpvC_error));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,smpvD_error));
  GetSignal()->SetCgwA(std::make_pair(sgwA,sgwA_error));
  GetSignal()->SetCgwB(std::make_pair(sgwB,sgwB_error));
  GetSignal()->SetCnorm(std::make_pair(norm,norm_error));

  GetBackground()->SetClwA(std::make_pair(blwA,blwA_error));
  GetBackground()->SetClwB(std::make_pair(blwB,blwB_error));
  GetBackground()->SetClwC(std::make_pair(blwC,blwC_error));
  GetBackground()->SetCshift(std::make_pair(bmpvS,bmpvS_error));
  GetBackground()->SetCgwA(std::make_pair(bgwA,bgwA_error));
  GetBackground()->SetCgwB(std::make_pair(bgwB,bgwB_error));
  GetBackground()->SetCgwC(std::make_pair(bgwC,bgwC_error));
  GetBackground()->SetCnorm(std::make_pair(1-norm,norm_error));
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundLag(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  //set each parameter
  double slwA  = par[0];
  double slwB  = par[1];
  double slwC  = par[2];
  double smpvA = par[3];
  double smpvB = par[4];
  double smpvC = par[5];
  double smpvD = par[6];
  double sgwA  = par[7];
  double sgwB  = par[8];
  double blwA  = par[9];
  double blwB  = par[10];
  double blwC  = par[11];
  double bmpvS = par[12];
  double bgwA  = par[13];
  double bgwB  = par[14];
  double bgwC  = par[15];
  double norm  = par[16];

  //define function to fit to each histogram
  double slw,smpv,sgw,snorm,blw,bmpv,bgw,bnorm;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = (CSMinuit->fRR[ibin].first-1        )/(CSMinuit->fRR[ibin].first+1     );
    //double x_l = (CSMinuit->fRR[ibin].first-1+blwS) /(CSMinuit->fRR[ibin].first+1+blwS );
    double x_m = (CSMinuit->fRR[ibin].first-1+bmpvS)/(CSMinuit->fRR[ibin].first+1+bmpvS);

    slw   =  slwA*ROOT::Math::laguerre(0,x) +  slwB*ROOT::Math::laguerre(1,x) +  slwC*ROOT::Math::laguerre(2,x);
    smpv  = smpvA*ROOT::Math::laguerre(0,x) + smpvB*ROOT::Math::laguerre(1,x) + smpvC*ROOT::Math::laguerre(2,x) + smpvD*ROOT::Math::laguerre(3,x);
    sgw   =  sgwA*ROOT::Math::laguerre(0,x) +  sgwB*ROOT::Math::laguerre(1,x);
    snorm = norm;

    blw   = blwA*ROOT::Math::laguerre(0,x) + blwB*ROOT::Math::laguerre(1,x) + blwC*ROOT::Math::laguerre(2,x);
    bmpv  = smpvA*ROOT::Math::laguerre(0,x_m) + smpvB*ROOT::Math::laguerre(1,x_m) + smpvC*ROOT::Math::laguerre(2,x_m) + smpvD*ROOT::Math::laguerre(3,x_m);
    bgw   = bgwA*ROOT::Math::laguerre(0,x) + bgwB*ROOT::Math::laguerre(1,x) + bgwC*ROOT::Math::laguerre(2,x);
    bnorm = 1-norm;

    flg->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//laguerre polynomials models mpv dependence
//********************************************************************
void CoherentSample::CoherentFitSignalLagMPV(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 12;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalLagMPV);

  Double_t arglist[11];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //Set starting values and step sizes for parameters
  double mean_norm = 0;
  for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  mean_norm = 0.4;//mean_norm / fInorm.size();

  fMinuit->mnparm(0,  "lw A" , 0.05  , 0.001, 0, 0, ierflg);
  fMinuit->mnparm(1,  "lw B" , 0     , 0.1  , 0, 0, ierflg);
  fMinuit->mnparm(2,  "lw C" , 0     , 0.1  , 0, 0, ierflg);
  fMinuit->mnparm(3,  "mpv A", -78   , 1    , 0, 0, ierflg);
  fMinuit->mnparm(4,  "mpv B",  295  , 10   , 0, 0, ierflg);
  fMinuit->mnparm(5,  "mpv C", -341  , 10   , 0, 0, ierflg);
  fMinuit->mnparm(6,  "mpv D",  136  , 10   , 0, 0, ierflg);
  fMinuit->mnparm(7,  "gw A" , 3.47  , 0.1  , 0, 0, ierflg);// 3.47869e+00
  fMinuit->mnparm(8,  "gw B" , -3.68 , 0.1  , 0, 0, ierflg);//-3.68145e+00
  fMinuit->mnparm(9,  "gw C" , 1.03  , 0.1  , 0, 0, ierflg);// 1.03852e+00
  fMinuit->mnparm(10, "norm" , 0.4   , 0.01 , 0, 0, ierflg);
  fMinuit->mnparm(11, "C"    , 0.01  , 0.01  , 0, 1, ierflg);

  fMinuit->FixParameter(1);
  fMinuit->FixParameter(2);
  
  // Now ready for minimization step
  arglist[0] = 2;
  fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  arglist[0] = 500000;
  arglist[1] = 1.;
  fMinuit->mnexcm("HESSE", arglist, 1, ierflg);
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
 
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(1,  fClwB.first,  fClwB.second);
  fMinuit->GetParameter(2,  fClwC.first,  fClwC.second);
  fMinuit->GetParameter(3,  fCmpvA.first, fCmpvA.second);
  fMinuit->GetParameter(4,  fCmpvB.first, fCmpvB.second);
  fMinuit->GetParameter(5,  fCmpvC.first, fCmpvC.second);
  fMinuit->GetParameter(6,  fCmpvD.first, fCmpvD.second);
  fMinuit->GetParameter(7,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(8,  fCgwB.first,  fCgwB.second);
  fMinuit->GetParameter(9,  fCgwC.first,  fCgwC.second);
  fMinuit->GetParameter(10, fCnorm.first, fCnorm.second);
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalLagMPV(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwA  = par[0];
  double lwB  = par[1];
  double lwC  = par[2];
  double mpvA = par[3];
  double mpvB = par[4];
  double mpvC = par[5];
  double mpvD = par[6];
  double gwA  = par[7];
  double gwB  = par[8];
  double gwC  = par[9];
  double norm = par[10];
  double C    = par[11];

  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  //TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  TF1* flg = new TF1("flg",CoherentFitUtils::LangausPlusConstant,1,30,5);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = CSMinuit->fRR[ibin].first;
    double x_t = (x-1)/(x+1);
    mpv  = mpvA*ROOT::Math::laguerre(0,x_t)+mpvB*ROOT::Math::laguerre(1,x_t)+mpvC*ROOT::Math::laguerre(2,x_t)+mpvD*ROOT::Math::laguerre(3,x_t);

    lw   = lwA + lwB*sqrt(mpv)+lwC*mpv;
    gw   = gwA + gwB*sqrt(mpv)+gwC*mpv;
    //std::cout << lw << " " << mpv << " " << norm << " " << gw << std::endl;
    flg->SetParameters(lw,mpv,norm,gw,C);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
    // CSMinuit->fh[ibin]->Draw();
    // flg->Draw("same");
    // gPad->Update();
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitBackgroundLagMPV(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 4;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackgroundLagMPV);

  Double_t arglist[11];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //Set starting values and step sizes for parameters
  double mean_norm = 0;
  for(int i = 0; i < (int)fInorm.size(); i++)mean_norm += fInorm[i].first;
  mean_norm = 0.1;//mean_norm / fInorm.size();

  fMinuit->mnparm(0,  "lw Q" , 0.1       , 10 , 0 , 0, ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(1,  "mpv S", 3.4       , 10 , 0 , 0 , ierflg);//0.9*0.65  , 1.1*0.65  , ierflg);//
  fMinuit->mnparm(2,  "gw Q" , 0.1       , 10 , 0 , 0 , ierflg);//0.9*2.25  , 1.1*2.25  , ierflg);//
  fMinuit->mnparm(3,  "norm" , mean_norm , 1  , 0 , 1 , ierflg);//0.9*0.88  , 1.1*0.88  , ierflg);//

  //fMinuit->FixParameter(0);
  //fMinuit->FixParameter(3);
  
  std::vector<TH1F*> h_rebin, h_save;
  for(int i = 0; i < (int)fh.size(); i++){
    h_rebin.push_back((TH1F*)fh[i]->Clone());
    h_rebin.back()->Rebin(2);
  }
  h_save = fh;
  fh = h_rebin;
    
  // Now ready for minimization step
  arglist[0] = 500000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
 
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first,  fClwA.second);
  fMinuit->GetParameter(1,  fCshift.first,  fCshift.second);
  fMinuit->GetParameter(2,  fCgwA.first,  fCgwA.second);
  fMinuit->GetParameter(3,  fCnorm.first, fCnorm.second);
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackgroundLagMPV(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double lwQ   = par[0];
  double shift = par[1];
  double gwQ   = par[2];
  double norm  = par[3];

  double smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;

  double slwA = CSMinuit->GetTrueSignal()->GetClwA().first;
  double slwB = CSMinuit->GetTrueSignal()->GetClwB().first;
  double slwC = CSMinuit->GetTrueSignal()->GetClwC().first;

  double sgwA = CSMinuit->GetTrueSignal()->GetCgwA().first;
  double sgwB = CSMinuit->GetTrueSignal()->GetCgwB().first;
  double sgwC = CSMinuit->GetTrueSignal()->GetCgwC().first;
      
  //define function to fit to each histogram
  double lw,mpv,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = CSMinuit->fRR[ibin].first+shift;
    double x_t = (x-1)/(x+1);
    mpv  = smpvA*ROOT::Math::laguerre(0,x_t)+smpvB*ROOT::Math::laguerre(1,x_t)+smpvC*ROOT::Math::laguerre(2,x_t)+smpvD*ROOT::Math::laguerre(3,x_t);
    lw   = sqrt(pow(slwA + slwB*sqrt(mpv)+slwC*mpv,2) + pow(lwQ*mpv,2));
    gw   = sqrt(pow(sgwA + sgwB*sqrt(mpv)+sgwC*mpv,2) + pow(gwQ*mpv,2));
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundLagMPV(){
//********************************************************************

  CSMinuit = this;

  //create Minuit
  const int CPAR = 14;
  const int NPAR = CPAR;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundLagMPV);

  Double_t arglist[10];
  Int_t ierflg = 0;

  arglist[0] = 0.5;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);

  //initial par
  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,sgwA,sgwB,sgwC,norm;
  double slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,sgwA_error,sgwB_error,sgwC_error, norm_error;
  double blwQ,bmpvS,bgwQ;
  double blwQ_error,bmpvS_error,bgwQ_error;

  slwA = CSMinuit->GetTrueSignal()->GetClwA().first;
  slwB = CSMinuit->GetTrueSignal()->GetClwB().first;
  slwC = CSMinuit->GetTrueSignal()->GetClwC().first;

  smpvA = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  smpvB = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  smpvC = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  smpvD = CSMinuit->GetTrueSignal()->GetCmpvD().first;

  sgwA = CSMinuit->GetTrueSignal()->GetCgwA().first;
  sgwB = CSMinuit->GetTrueSignal()->GetCgwB().first;
  sgwC = CSMinuit->GetTrueSignal()->GetCgwC().first;

  norm = CSMinuit->GetTrueSignal()->GetCnorm().first;
  
  blwQ = CSMinuit->GetTrueBackground()->GetClwA().first;

  bmpvS = CSMinuit->GetTrueBackground()->GetCshift().first;

  bgwQ = CSMinuit->GetTrueBackground()->GetCgwA().first;

  slwA_error = CSMinuit->GetTrueSignal()->GetClwA().second;
  slwB_error = CSMinuit->GetTrueSignal()->GetClwB().second;
  slwC_error = CSMinuit->GetTrueSignal()->GetClwC().second;
   
  smpvA_error = CSMinuit->GetTrueSignal()->GetCmpvA().second;
  smpvB_error = CSMinuit->GetTrueSignal()->GetCmpvB().second;
  smpvC_error = CSMinuit->GetTrueSignal()->GetCmpvC().second;
  smpvD_error = CSMinuit->GetTrueSignal()->GetCmpvD().second;
   
  sgwA_error = CSMinuit->GetTrueSignal()->GetCgwA().second;
  sgwB_error = CSMinuit->GetTrueSignal()->GetCgwB().second;
   
  blwQ_error = CSMinuit->GetTrueBackground()->GetClwA().second;
   
  bmpvS_error = CSMinuit->GetTrueBackground()->GetCshift().second;
   
  bgwQ_error = CSMinuit->GetTrueBackground()->GetCgwA().second;

  norm_error = CSMinuit->GetTrueBackground()->GetCnorm().second;

  fMinuit->mnparm(0,  "lw A"      , slwA  , 0.1 ,0.95*slwA   ,1.05*slwA   , ierflg);  // 2.73938e+00 
  fMinuit->mnparm(1,  "lw B"      , slwB  , 0.1 ,0.95*slwB   ,1.05*slwB   , ierflg);  //-6.30265e+00
  fMinuit->mnparm(2,  "lw C"      , slwC  , 0.1 ,0.95*slwC   ,1.05*slwC   , ierflg);  // 5.22968e+00
  fMinuit->mnparm(3,  "mpv A"     , smpvA , 0.1 ,0.95*smpvA  ,1.05*smpvA  , ierflg);  //-7.80112e+01
  fMinuit->mnparm(4,  "mpv B"     , smpvB , 0.1 ,0.95*smpvB  ,1.05*smpvB  , ierflg);  // 2.95159e+02
  fMinuit->mnparm(5,  "mpv C"     , smpvC , 0.1 ,0.95*smpvC  ,1.05*smpvC  , ierflg);  //-3.41434e+02
  fMinuit->mnparm(6,  "mpv D"     , smpvD , 0.1 ,0.95*smpvD  ,1.05*smpvD  , ierflg);  // 1.36370e+02
  fMinuit->mnparm(7,  "gw A"      , sgwA  , 0.1 ,0.95*sgwA   ,1.05*sgwA   , ierflg);  // 7.61715e-02
  fMinuit->mnparm(8,  "gw B"      , sgwB  , 0.1 ,0.95*sgwB   ,1.05*sgwB   , ierflg);  // 2.02543e+00
  fMinuit->mnparm(9,  "gw C"      , sgwC  , 0.1 ,0.95*sgwC   ,1.05*sgwC   , ierflg);  // 2.02543e+00a
  fMinuit->mnparm(10, "blw Q"     , blwQ  , 0.1 ,0,0  , ierflg);  // 5.96330e-01
  fMinuit->mnparm(11, "mpv shift" , bmpvS , 0.1 ,0,0  , ierflg);
  fMinuit->mnparm(12, "bgw Q"     , bgwQ  , 0.1 ,0,0  , ierflg);  // 4.21610e+00
  fMinuit->mnparm(13, "norm"      , norm  , 0.1 ,0.95*norm   ,1   , ierflg);// 8.74262e-01

  // fMinuit->FixParameter(0);
  // fMinuit->FixParameter(1);
  // fMinuit->FixParameter(2);
  // fMinuit->FixParameter(3);
  // fMinuit->FixParameter(4);
  // fMinuit->FixParameter(5);
  // fMinuit->FixParameter(6);
  // fMinuit->FixParameter(7);
  // fMinuit->FixParameter(8);
  // fMinuit->FixParameter(9);
  fMinuit->FixParameter(10);
  fMinuit->FixParameter(11);
  fMinuit->FixParameter(12);
  // fMinuit->FixParameter(13);

  // // Calcule hesse
  // arglist[0] = 50000;
  // fMinuit->mnexcm("HESSE", arglist, 1, ierflg);
  
  // // Now ready for minimization step
  // // Set strategy to 2, we want TMinuit to try its best
  // arglist[0] = 2;
  // fMinuit->mnexcm("SET STR", arglist, 1, ierflg);
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);

  // arglist[1] = 3;
  // arglist[2] = 4;
  // arglist[3] = 5;
  // arglist[4] = 6;
  // fMinuit->mnexcm("MINOS", arglist, 5, ierflg);

  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);

  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  slwA  , slwA_error);
  fMinuit->GetParameter(1,  slwB  , slwB_error);
  fMinuit->GetParameter(2,  slwC  , slwC_error);
  fMinuit->GetParameter(3,  smpvA , smpvA_error);
  fMinuit->GetParameter(4,  smpvB , smpvB_error);
  fMinuit->GetParameter(5,  smpvC , smpvC_error);
  fMinuit->GetParameter(6,  smpvD , smpvD_error);
  fMinuit->GetParameter(7,  sgwA  , sgwA_error);
  fMinuit->GetParameter(8,  sgwB  , sgwB_error);
  fMinuit->GetParameter(9,  sgwC  , sgwC_error);
  fMinuit->GetParameter(10,  blwQ  , blwQ_error);
  fMinuit->GetParameter(11, bmpvS , bmpvS_error);
  fMinuit->GetParameter(12, bgwQ  , bgwQ_error);
  fMinuit->GetParameter(13, norm  , norm_error);

  GetSignal()->SetClwA(std::make_pair(slwA,slwA_error));
  GetSignal()->SetClwB(std::make_pair(slwB,slwB_error));
  GetSignal()->SetClwC(std::make_pair(slwC,slwC_error));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,smpvC_error));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,smpvD_error));
  GetSignal()->SetCgwA(std::make_pair(sgwA,sgwA_error));
  GetSignal()->SetCgwB(std::make_pair(sgwB,sgwB_error));
  GetSignal()->SetCgwC(std::make_pair(sgwC,sgwC_error));
  GetSignal()->SetCnorm(std::make_pair(norm,norm_error));

  GetBackground()->SetClwA(std::make_pair(blwQ,blwQ_error));
  // GetBackground()->SetClwB(std::make_pair(blwB,blwB_error));
  // GetBackground()->SetClwC(std::make_pair(blwC,blwC_error));
  GetBackground()->SetCshift(std::make_pair(bmpvS,bmpvS_error));
  GetBackground()->SetCgwA(std::make_pair(bgwQ,bgwQ_error));
  // GetBackground()->SetCgwB(std::make_pair(bgwB,bgwB_error));
  // GetBackground()->SetCgwC(std::make_pair(bgwC,bgwC_error));
  GetBackground()->SetCnorm(std::make_pair(1-norm,norm_error));

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundLagMPV(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  //set each parameter
  double slwA  = par[0];
  double slwB  = par[1];
  double slwC  = par[2];
  double smpvA = par[3];
  double smpvB = par[4];
  double smpvC = par[5];
  double smpvD = par[6];
  double sgwA  = par[7];
  double sgwB  = par[8];
  double sgwC  = par[9];
  double blwQ  = par[10];
  double bmpvS = par[11];
  double bgwQ  = par[12];
  double norm  = par[13];

  //define function to fit to each histogram
  double slw,smpv,sgw,snorm,blw,bmpv,bgw,bnorm;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double x   = (CSMinuit->fRR[ibin].first-1      )/(CSMinuit->fRR[ibin].first+1     );
    double x_m = (CSMinuit->fRR[ibin].first-1+bmpvS)/(CSMinuit->fRR[ibin].first+1+bmpvS);

    smpv  = smpvA*ROOT::Math::laguerre(0,x) + smpvB*ROOT::Math::laguerre(1,x) + smpvC*ROOT::Math::laguerre(2,x) + smpvD*ROOT::Math::laguerre(3,x);
    slw   = slwA + slwB*sqrt(smpv) + slwC*smpv;
    sgw   = sgwA + sgwB*sqrt(smpv) + sgwC*smpv;
    snorm = norm;

    bmpv  = smpvA*ROOT::Math::laguerre(0,x_m) + smpvB*ROOT::Math::laguerre(1,x_m) + smpvC*ROOT::Math::laguerre(2,x_m) + smpvD*ROOT::Math::laguerre(3,x_m);
    blw   = sqrt(pow(slwA + slwB*sqrt(bmpv) + slwC*bmpv,2)+pow(blwQ*bmpv,2));
    bgw   = sqrt(pow(sgwA + sgwB*sqrt(bmpv) + sgwC*bmpv,2)+pow(bgwQ*bmpv,2));
    bnorm = 1-norm;

    flg->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}


//********************************************************************
void CoherentSample::StoreCoherentFits(){
//********************************************************************

  if(fType != SampleTypeEnum::kSignalPlusBackground){

    CoherentSample* satb = NULL;
    if(fType == SampleTypeEnum::kTrueBackground)satb = GetTrueSignal();
    if(fType == SampleTypeEnum::kBackground)    satb = GetSignal();
    
    if(fBackgroundModel == BackgroundModelEnum::kQuadraticWidths){
      //fClwFit = new TF1("lw_par" ,CoherentFitUtils::QuadraticABCParametrization,0,60,6);
      //fClwFit->SetParameters(satb->GetClwA().first,satb->GetClwB().first,satb->GetClwC().first, fClwA.first, fClwB.first, fClwC.first);
      fClwFit = new TF1("lw_par","ROOT::Math::Chebyshev2((x-1)/(x+1),[0],[1],[2])",0,30);
      fClwFit->SetParameters(fClwA,fClwB,fClwC);
    }
    else{
      fClwFit = new TF1("lw_par" ,CoherentFitUtils::ABCParametrization,0,60,4);
      fClwFit->SetParameters(fClwA.first,fClwB.first,fClwC.first,fClwQa.first);
    }

    //fCmpvFit = new TF1("mpv_par",CoherentFitUtils::ABCDRParametrization,0,60,6);
    fCmpvFit = new TF1("mpv_par","ROOT::Math::Chebyshev4((x-1)/(x+1),[0],[1],[2],[3],[4])",0,30);
    fCmpvFit->SetParameters(fCmpvA.first,fCmpvB.first,fCmpvC.first,fCmpvD.first,fCmpvR.first,fCshift.first);
    
    if(fBackgroundModel == BackgroundModelEnum::kQuadraticWidths){
      fCgwFit = new TF1("gw_par" ,CoherentFitUtils::QuadraticABCParametrization,0,60,6);
      fCgwFit->SetParameters(satb->GetCgwA().first,satb->GetCgwB().first,satb->GetCgwC().first, fCgwA.first, fCgwB.first, fCgwC.first);
    }
    else{
      fCgwFit = new TF1("gw_par" ,CoherentFitUtils::ABCParametrization,0,60,4);
      fCgwFit->SetParameters(fCgwA.first,fCgwB.first,fCgwC.first,fCgwQa.first);
    }
    
    //store individual histogram fits
    for(int i = 0; i < (int)fRR.size(); i++){
      std::stringstream ssi;
      ssi << i;
      TF1* f = new TF1(("CF_"+ssi.str()+"").c_str(),CoherentFitUtils::Langaus,1,30,4);

      double lw,mpv,norm,gw;
      
      lw   = fClwFit->Eval(fRR[i].first);
      mpv  = fCmpvFit->Eval(fRR[i].first);
      norm = fCnorm.first;
      gw   = fCgwFit->Eval(fRR[i].first);

      f->SetParameters(lw,mpv,norm,gw);		       
      fCFit.push_back(f);
      //fCIntegral.push_back(CoherentFitUtils::GetFunctionNormalizationInsideHistogramBoundaries(fh[i],f));
    }
  }
  else{
    //store parametric functions
    GetSignal()->StoreCoherentFits();
    GetBackground()->StoreCoherentFits();

    //store individual histogram fits
    for(int i = 0; i < (int)fh.size(); i++){
      std::stringstream ssi;
      ssi << i;
      TF1* f = new TF1(("CF_b"+ssi.str()+"").c_str(),CoherentFitUtils::DoubleLangaus,1,30,8);

      double slw, smpv, snorm, sgw, blw, bmpv, bnorm, bgw;
      
      slw   = GetSignal()->GetClwFit()->Eval(fRR[i].first);
      smpv  = GetSignal()->GetCmpvFit()->Eval(fRR[i].first);
      snorm = GetSignal()->GetCnorm().first;
      sgw   = GetSignal()->GetCgwFit()->Eval(fRR[i].first);
      blw   = GetBackground()->GetClwFit()->Eval(fRR[i].first);
      bmpv  = GetBackground()->GetCmpvFit()->Eval(fRR[i].first);
      bnorm = GetBackground()->GetCnorm().first;
      bgw   = GetBackground()->GetCgwFit()->Eval(fRR[i].first);
      
      f->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
      fCFit.push_back(f);
      fCIntegral.push_back(CoherentFitUtils::GetFunctionNormalizationInsideHistogramBoundaries(fh[i],f));
    }
  }
}

//********************************************************************
void CoherentSample::CoherentFit(){
//********************************************************************

  std::cout << "coherent fit" << std::endl;
  
  if(fType == SampleTypeEnum::kTrueSignal){
    CoherentFitSignal();
  }
  else if(fType == SampleTypeEnum::kTrueBackground){
    if(fBackgroundModel == BackgroundModelEnum::kShift)                CoherentFitBackgroundShift();
    else if (fBackgroundModel == BackgroundModelEnum::k3Par)           CoherentFitBackground3Par();
    else if (fBackgroundModel == BackgroundModelEnum::kQuadraticWidths)CoherentFitBackgroundQuadraticWidths();
    else                                                               CoherentFitBackgroundAllFree();
  }
  else if(fType == SampleTypeEnum::kSignalPlusBackground){
    if(fBackgroundModel == BackgroundModelEnum::kShift)CoherentFitSignalPlusBackgroundShift();
    else if (fBackgroundModel == BackgroundModelEnum::kQuadraticWidths)CoherentFitSignalPlusBackgroundQuadraticWidths();
    else CoherentFitSignalPlusBackgroundAllFree();
  }
}

//********************************************************************
void CoherentSample::CoherentFitBackgroundAllFree(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 11;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackgroundAllFree);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {fClwA.first, fClwB.first, fClwC.first,
			   fCmpvA.first, fCmpvB.first, fCmpvC.first, fCmpvD.first, fCmpvR.first,
			   fCgwA.first, fCgwB.first, fCgwC.first};
  Double_t step[NPAR]   = {         0.1,          0.1,          0.1,           0.1,           0.1,           0.1,           0.1,           0.1,           0.1,          0.1,         0.1};
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = fInorm[ipar].first;
    step[ipar+CPAR]   = 0.1;
  }
  fMinuit->mnparm(0,  "lwA" ,  vstart[0] , step[0],  1, 20, ierflg);  ;//0, 0, ierflg);
  fMinuit->mnparm(1,  "lwB" ,  vstart[1] , step[1],  0, 0, ierflg);
  fMinuit->mnparm(2,  "lwC" ,  vstart[2] , step[2],  0.05, 1, ierflg);//0, 0, ierflg);
  fMinuit->mnparm(3,  "mpvA",  vstart[3] , step[3],  0, 0, ierflg);
  fMinuit->mnparm(4,  "mpvB",  vstart[4] , step[5],  0, 0, ierflg);
  fMinuit->mnparm(5,  "mpvC",  vstart[5] , step[5],  0, 0, ierflg);
  fMinuit->mnparm(6,  "mpvD",  vstart[6] , step[6],  0, 0, ierflg);
  fMinuit->mnparm(7,  "mpvR",  vstart[7] , step[7],  0, 0, ierflg);
  fMinuit->mnparm(8,  "gwA" ,  vstart[8] , step[8],  0, 0, ierflg);
  fMinuit->mnparm(9,  "gwB" ,  vstart[9] , step[9],  0, 0, ierflg);
  fMinuit->mnparm(10, "gwC" ,  vstart[10], step[10], 0, 0, ierflg);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 1, ierflg);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwA.first ,  fClwA.second);
  fMinuit->GetParameter(1,  fClwB.first ,  fClwB.second);
  fMinuit->GetParameter(2,  fClwC.first ,  fClwC.second);
  fMinuit->GetParameter(3,  fCmpvA.first,  fCmpvA.second);
  fMinuit->GetParameter(4,  fCmpvB.first,  fCmpvB.second);
  fMinuit->GetParameter(5,  fCmpvC.first,  fCmpvC.second);
  fMinuit->GetParameter(6,  fCmpvD.first,  fCmpvD.second);
  fMinuit->GetParameter(7,  fCmpvR.first,  fCmpvR.second);
  fMinuit->GetParameter(8,  fCgwA.first ,  fCgwA.second);
  fMinuit->GetParameter(9,  fCgwB.first ,  fCgwB.second);
  fMinuit->GetParameter(10, fCgwC.first ,  fCgwC.second);
  for(int ipar = 0; ipar < NBINS; ipar++){
    double norm, norm_error;
    fMinuit->GetParameter(ipar+CPAR, norm, norm_error);
    fCnorm.push_back(std::make_pair(norm, norm_error));
  }

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackgroundAllFree(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
  //********************************************************************
  
  const int CPAR = 11;
  
  //set each parameter
  double lwA   = par[0];
  double lwB   = par[1];
  double lwC   = par[2];
  double mpvA  = par[3];
  double mpvB  = par[4];
  double mpvC  = par[5];
  double mpvD  = par[6];
  double mpvR  = par[7];
  double gwA   = par[8];
  double gwB   = par[9];
  double gwC   = par[10];
  
  //define function to fit to each histogram
  double lw,mpv,norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double lw_par[]  = {lwA,lwB,lwC,0};
    double mpv_par[] = {mpvA,mpvB,mpvC,mpvD,mpvR,0};
    double gw_par[]  = {gwA,gwB,gwC,0};
    double RR_par[]  = {CSMinuit->fRR[ibin].first};
    
    lw   = CoherentFitUtils::ABCParametrization(RR_par,lw_par);
    mpv  = CoherentFitUtils::ABCDRParametrization(RR_par,mpv_par);
    gw   = CoherentFitUtils::ABCParametrization(RR_par,gw_par);
    norm = par[CPAR+ibin];
    
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundAllFree(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 22;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundAllFree);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,smpvR,sgwA,sgwB,sgwC,blwA,blwB,blwC,bmpvA,bmpvB,bmpvC,bmpvD,bmpvR,bgwA,bgwB,bgwC,slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,smpvR_error,sgwA_error,sgwB_error,sgwC_error,blwA_error,blwB_error,blwC_error,bmpvA_error,bmpvB_error,bmpvC_error,bmpvD_error,bmpvR_error,bgwA_error,bgwB_error,bgwC_error;
  slwA = GetSignal()->GetClwA().first;
  slwB = GetSignal()->GetClwB().first;
  slwC = GetSignal()->GetClwC().first;
  smpvA = GetSignal()->GetCmpvA().first;
  smpvB = GetSignal()->GetCmpvB().first;
  smpvC = GetSignal()->GetCmpvC().first;
  smpvD = GetSignal()->GetCmpvD().first;
  smpvR = GetSignal()->GetCmpvR().first;
  sgwA = GetSignal()->GetCgwA().first;
  sgwB = GetSignal()->GetCgwB().first;
  sgwC = GetSignal()->GetCgwC().first;
  blwA = GetBackground()->GetClwA().first;
  blwB = GetBackground()->GetClwB().first;
  blwC = GetBackground()->GetClwC().first;
  bmpvA = GetBackground()->GetCmpvA().first;
  bmpvB = GetBackground()->GetCmpvB().first;
  bmpvC = GetBackground()->GetCmpvC().first;
  bmpvD = GetBackground()->GetCmpvD().first;
  bmpvR = GetBackground()->GetCmpvR().first;
  bgwA = GetBackground()->GetCgwA().first;
  bgwB = GetBackground()->GetCgwB().first;
  bgwC = GetBackground()->GetCgwC().first;
  Double_t vstart[NPAR] = {slwA, slwB, slwC, smpvA, smpvB, smpvC, smpvD, smpvR, sgwA, sgwB, sgwC,
			   blwA, blwB, blwC, bmpvA, bmpvB, bmpvC, bmpvD, bmpvR, bgwA, bgwB, bgwC};
  Double_t step[NPAR]   = {0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01};
  std::vector<std::pair<double,double>> snorm = GetSignal()->GetCnorm();
  std::vector<std::pair<double,double>> bnorm = GetBackground()->GetCnorm();
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = (snorm[ipar].first+(1-bnorm[ipar].first))/2;
    step[ipar+CPAR]   = 0.01;
  }
  fMinuit->mnparm(0,  "s lw A" , vstart[0] ,  step[0], 0, 0, ierflg);
  fMinuit->mnparm(1,  "s lw B" , vstart[1] ,  step[1], 0, 0, ierflg);
  fMinuit->mnparm(2,  "s lw C" , vstart[2] ,  step[2], 0, 0, ierflg);
  fMinuit->mnparm(3,  "s mpv A", vstart[3] ,  step[3], 0, 0, ierflg);
  fMinuit->mnparm(4,  "s mpv B", vstart[4] ,  step[4], 0, 0, ierflg);
  fMinuit->mnparm(5,  "s mpv C", vstart[5] ,  step[5], 0, 0, ierflg);
  fMinuit->mnparm(6,  "s mpv D", vstart[6] ,  step[6], 0, 0, ierflg);
  fMinuit->mnparm(7,  "s mpv R", vstart[7] ,  step[7], 0, 0, ierflg);
  fMinuit->mnparm(8,  "s gw A" , vstart[8] ,  step[8], 0, 0, ierflg);
  fMinuit->mnparm(9,  "s gw B" , vstart[9] ,  step[9], 0, 0, ierflg);
  fMinuit->mnparm(10, "s gw C" , vstart[10], step[10], 0, 0, ierflg);
  fMinuit->mnparm(11, "b lw A" , vstart[11], step[11], 0, 0, ierflg);
  fMinuit->mnparm(12, "b lw B" , vstart[12], step[12], 0, 0, ierflg);
  fMinuit->mnparm(13, "b lw C" , vstart[13], step[13], 0, 0, ierflg);
  fMinuit->mnparm(14, "b mpv A", vstart[14], step[14], 0, 0, ierflg);
  fMinuit->mnparm(15, "b mpv B", vstart[15], step[15], 0, 0, ierflg);
  fMinuit->mnparm(16, "b mpv C", vstart[16], step[16], 0, 0, ierflg);
  fMinuit->mnparm(17, "b mpv D", vstart[17], step[17], 0, 0, ierflg);
  fMinuit->mnparm(18, "b mpv R", vstart[18], step[18], 0, 0, ierflg);
  fMinuit->mnparm(19, "b gw A" , vstart[19], step[19], 0, 0, ierflg);
  fMinuit->mnparm(20, "b gw B" , vstart[20], step[20], 0, 0, ierflg);
  fMinuit->mnparm(21, "b gw C" , vstart[21], step[21], 0, 0, ierflg);
  fMinuit->FixParameter(0);
  fMinuit->FixParameter(1);
  fMinuit->FixParameter(2);
  fMinuit->FixParameter(3);
  fMinuit->FixParameter(4);
  fMinuit->FixParameter(5);
  fMinuit->FixParameter(6);
  fMinuit->FixParameter(7);
  fMinuit->FixParameter(8);
  fMinuit->FixParameter(9);
  fMinuit->FixParameter(10);
  //fMinuit->FixParameter(11);
  //fMinuit->FixParameter(12);
  //fMinuit->FixParameter(13);
  //fMinuit->FixParameter(14);
  //fMinuit->FixParameter(15);
  //fMinuit->FixParameter(16);
  //fMinuit->FixParameter(17);
  //fMinuit->FixParameter(18);
  //fMinuit->FixParameter(19);
  //fMinuit->FixParameter(20);
  //fMinuit->FixParameter(21);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("s Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 1, ierflg);
    //fMinuit->FixParameter(ipar+CPAR);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  slwA , slwA_error);
  fMinuit->GetParameter(1,  slwB , slwB_error);
  fMinuit->GetParameter(2,  slwC , slwC_error);
  fMinuit->GetParameter(3,  smpvA, smpvA_error);
  fMinuit->GetParameter(4,  smpvB, smpvB_error);
  fMinuit->GetParameter(5,  smpvC, smpvC_error);
  fMinuit->GetParameter(6,  smpvD, smpvD_error);
  fMinuit->GetParameter(7,  smpvR, smpvR_error);
  fMinuit->GetParameter(8,  sgwA , sgwA_error);
  fMinuit->GetParameter(9,  sgwB , sgwB_error);
  fMinuit->GetParameter(10, sgwC , sgwC_error);
  fMinuit->GetParameter(11, blwA , blwA_error);
  fMinuit->GetParameter(12, blwB , blwB_error);
  fMinuit->GetParameter(13, blwC , blwC_error);
  fMinuit->GetParameter(14, bmpvA, bmpvA_error);
  fMinuit->GetParameter(15, bmpvB, bmpvB_error);
  fMinuit->GetParameter(16, bmpvC, bmpvC_error);
  fMinuit->GetParameter(17, bmpvD, bmpvD_error);
  fMinuit->GetParameter(18, bmpvR, bmpvR_error);
  fMinuit->GetParameter(19, bgwA , bgwA_error);
  fMinuit->GetParameter(20, bgwB , bgwB_error);
  fMinuit->GetParameter(21, bgwC , bgwC_error);
  std::vector<std::pair<double,double>> sn;
  std::vector<std::pair<double,double>> bn;
  for(int ipar = 0; ipar < NBINS; ipar++){
    double snorm, snorm_error;//, bnorm, bnorm_error;
    fMinuit->GetParameter(ipar+CPAR, snorm, snorm_error);
    sn.push_back(std::make_pair(snorm, snorm_error));
    //fMinuit->GetParameter(ipar+CPAR+NBINS, bnorm, bnorm_error);
    bn.push_back(std::make_pair(1-snorm, snorm_error));
  }

  GetSignal()->SetClwA(std::make_pair(slwA,slwA_error));
  GetSignal()->SetClwB(std::make_pair(slwB,slwB_error));
  GetSignal()->SetClwC(std::make_pair(slwC,slwC_error));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,smpvR_error));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,smpvC_error));
  GetSignal()->SetCmpvR(std::make_pair(smpvR,smpvD_error));
  GetSignal()->SetCgwA(std::make_pair(sgwA,sgwA_error));
  GetSignal()->SetCgwB(std::make_pair(sgwB,sgwB_error));
  GetSignal()->SetCgwC(std::make_pair(sgwC,sgwC_error));
  GetSignal()->SetCnorm(sn);

  GetBackground()->SetClwA(std::make_pair(blwA,blwA_error));
  GetBackground()->SetClwB(std::make_pair(blwB,blwB_error));
  GetBackground()->SetClwC(std::make_pair(blwC,blwC_error));
  GetBackground()->SetCmpvA(std::make_pair(bmpvA,bmpvA_error));
  GetBackground()->SetCmpvB(std::make_pair(bmpvB,bmpvB_error));
  GetBackground()->SetCmpvC(std::make_pair(bmpvC,bmpvR_error));
  GetBackground()->SetCmpvD(std::make_pair(bmpvD,bmpvC_error));
  GetBackground()->SetCmpvR(std::make_pair(bmpvR,bmpvD_error));
  GetBackground()->SetCgwA(std::make_pair(bgwA,bgwA_error));
  GetBackground()->SetCgwB(std::make_pair(bgwB,bgwB_error));
  GetBackground()->SetCgwC(std::make_pair(bgwC,bgwC_error));
  GetBackground()->SetCnorm(bn);

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundAllFree(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  const int CPAR = 22;
  //const int NBINS = CSMinuit->fh.size();
  
  //set each parameter
  double slwA  = par[0];
  double slwB  = par[1];
  double slwC  = par[2];
  double smpvA = par[3];
  double smpvB = par[4];
  double smpvC = par[5];
  double smpvD = par[6];
  double smpvR = par[7];
  double sgwA  = par[8];
  double sgwB  = par[9];
  double sgwC  = par[10];
  double blwA  = par[11];
  double blwB  = par[12];
  double blwC  = par[13];
  double bmpvA = par[14];
  double bmpvB = par[15];
  double bmpvC = par[16];
  double bmpvD = par[17];
  double bmpvR = par[18];
  double bgwA  = par[19];
  double bgwB  = par[20];
  double bgwC  = par[21];
  
  //define function to fit to each histogram
  double slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double slw_par[]  = {slwA,slwB,slwC,0};
    double smpv_par[] = {smpvA,smpvB,smpvC,smpvD,smpvR,0};
    double sgw_par[]  = {sgwA,sgwB,sgwC,0};
    double blw_par[]  = {blwA,blwB,blwC,0};
    double bmpv_par[] = {bmpvA,bmpvB,bmpvC,bmpvD,bmpvR,0};
    double bgw_par[]  = {bgwA,bgwB,bgwC,0};
    double RR_par[]   = {CSMinuit->fRR[ibin].first};
    
    slw   = CoherentFitUtils::ABCParametrization(RR_par,slw_par);
    smpv  = CoherentFitUtils::ABCDRParametrization(RR_par,smpv_par);
    sgw   = CoherentFitUtils::ABCParametrization(RR_par,sgw_par);
    snorm = par[CPAR+ibin];
    blw   = CoherentFitUtils::ABCParametrization(RR_par,blw_par);
    bmpv  = CoherentFitUtils::ABCDRParametrization(RR_par,bmpv_par);
    bgw   = CoherentFitUtils::ABCParametrization(RR_par,bgw_par);
    bnorm = 1-snorm;//par[CPAR+ibin+NBINS];
    
    flg->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
    if(smpv>bmpv)
      Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
    else
      Likelihood = Likelihood + 0.1*CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//shift on mpv

//********************************************************************
void CoherentSample::CoherentFitBackgroundShift(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 7;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackgroundShift);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {1, fClwA.first, fClwB.first, fClwC.first, fCgwA.first, fCgwB.first, fCgwC.first};
  Double_t step[NPAR]   = {0.1 ,       0.1,         0.1,         0.1,         0.1,         0.1,         0.1};
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = fInorm[ipar].first;
    step[ipar+CPAR]   = 0.1;
  }
  fMinuit->mnparm(0,  "shift",  vstart[0],  step[0],  0, 0, ierflg);
  fMinuit->mnparm(1,  "lwA"  ,  vstart[1],  step[1],  1, 20, ierflg);
  fMinuit->mnparm(2,  "lwB"  ,  vstart[2],  step[2],  0, 0, ierflg);
  fMinuit->mnparm(3,  "lwC"  ,  vstart[3],  step[3],  0.05, 1, ierflg);
  fMinuit->mnparm(4,  "gwA"  ,  vstart[4],  step[4],  0, 0, ierflg);
  fMinuit->mnparm(5,  "gwB"  ,  vstart[5],  step[5],  0, 0, ierflg);
  fMinuit->mnparm(6,  "gwC"  ,  vstart[6],  step[6],  0, 0, ierflg);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 1, ierflg);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fCshift.first,  fCshift.second);
  fMinuit->GetParameter(1,  fClwA.first  ,  fClwA.second);
  fMinuit->GetParameter(2,  fClwB.first  ,  fClwB.second);
  fMinuit->GetParameter(3,  fClwC.first  ,  fClwC.second);
  fMinuit->GetParameter(4,  fCgwA.first  ,  fCgwA.second);
  fMinuit->GetParameter(5,  fCgwB.first  ,  fCgwB.second);
  fMinuit->GetParameter(6,  fCgwC.first  ,  fCgwC.second);
  for(int ipar = 0; ipar < NBINS; ipar++){
    double norm, norm_error;
    fMinuit->GetParameter(ipar+CPAR, norm, norm_error);
    fCnorm.push_back(std::make_pair(norm, norm_error));
  }

  fCmpvA = fTrueSignal->GetCmpvA();
  fCmpvB = fTrueSignal->GetCmpvB();
  fCmpvC = fTrueSignal->GetCmpvC();
  fCmpvD = fTrueSignal->GetCmpvD();
  fCmpvR = fTrueSignal->GetCmpvR();	  
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackgroundShift(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  const int CPAR = 7;
  
  //set each parameter
  double shift = par[0];
  double lwA   = par[1];
  double lwB   = par[2];
  double lwC   = par[3];
  double mpvA  = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double mpvB  = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double mpvC  = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double mpvD  = CSMinuit->GetTrueSignal()->GetCmpvD().first;
  double mpvR  = CSMinuit->GetTrueSignal()->GetCmpvR().first;
  double gwA   = par[4];
  double gwB   = par[5];
  double gwC   = par[6];

  //define function to fit to each histogram
  double lw,mpv,norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double lw_par[]   = {lwA,lwB,lwC,0};
    double mpv_par[]  = {mpvA,mpvB,mpvC,mpvD,mpvR,shift};
    double gw_par[]   = {gwA,gwB,gwC,0};
    double RR_par[]   = {CSMinuit->fRR[ibin].first};
    lw   = CoherentFitUtils::ABCParametrization(RR_par,lw_par);
    mpv  = CoherentFitUtils::ABCDRParametrization(RR_par,mpv_par);
    gw   = CoherentFitUtils::ABCParametrization(RR_par,gw_par);
    norm = par[CPAR+ibin];
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//********************************************************************
void CoherentSample::CoherentFitSignalPlusBackgroundShift(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 18;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnSignalPlusBackgroundShift);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  double slwA,slwB,slwC,smpvA,smpvB,smpvC,smpvD,smpvR,sgwA,sgwB,sgwC,blwA,blwB,blwC,bshift,bgwA,bgwB,bgwC,slwA_error,slwB_error,slwC_error,smpvA_error,smpvB_error,smpvC_error,smpvD_error,smpvR_error,sgwA_error,sgwB_error,sgwC_error,blwA_error,blwB_error,blwC_error,bshift_error,bgwA_error,bgwB_error,bgwC_error;
  slwA = GetSignal()->GetClwA().first;
  slwB = GetSignal()->GetClwB().first;
  slwC = GetSignal()->GetClwC().first;
  smpvA = GetSignal()->GetCmpvA().first;
  smpvB = GetSignal()->GetCmpvB().first;
  smpvC = GetSignal()->GetCmpvC().first;
  smpvD = GetSignal()->GetCmpvD().first;
  smpvR = GetSignal()->GetCmpvR().first;
  sgwA = GetSignal()->GetCgwA().first;
  sgwB = GetSignal()->GetCgwB().first;
  sgwC = GetSignal()->GetCgwC().first;
  blwA = GetBackground()->GetClwA().first;
  blwB = GetBackground()->GetClwB().first;
  blwC = GetBackground()->GetClwC().first;
  bshift = GetBackground()->GetCshift().first;
  bgwA = GetBackground()->GetCgwA().first;
  bgwB = GetBackground()->GetCgwB().first;
  bgwC = GetBackground()->GetCgwC().first;
  Double_t vstart[NPAR] = {slwA, slwB, slwC, smpvA, smpvB, smpvC, smpvD, smpvR, sgwA, sgwB, sgwC,
			   blwA, blwB, blwC, bshift,                            bgwA, bgwB, bgwC};
  Double_t step[NPAR]   = {0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01,0.01};
  std::vector<std::pair<double,double>> snorm = GetSignal()->GetCnorm();
  std::vector<std::pair<double,double>> bnorm = GetBackground()->GetCnorm();
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = (snorm[ipar].first+(1-bnorm[ipar].first))/2;
    step[ipar+CPAR]   = 0.01;
  }
  fMinuit->mnparm(0,  "s lw A" , vstart[0] ,  step[0], 0, 0, ierflg);
  fMinuit->mnparm(1,  "s lw B" , vstart[1] ,  step[1], 0, 0, ierflg);
  fMinuit->mnparm(2,  "s lw C" , vstart[2] ,  step[2], 0, 0, ierflg);
  fMinuit->mnparm(3,  "s mpv A", vstart[3] ,  step[3], 0, 0, ierflg);
  fMinuit->mnparm(4,  "s mpv B", vstart[4] ,  step[4], 0, 0, ierflg);
  fMinuit->mnparm(5,  "s mpv C", vstart[5] ,  step[5], 0, 0, ierflg);
  fMinuit->mnparm(6,  "s mpv D", vstart[6] ,  step[6], 0, 0, ierflg);
  fMinuit->mnparm(7,  "s mpv R", vstart[7] ,  step[7], 0, 0, ierflg);
  fMinuit->mnparm(8,  "s gw A" , vstart[8] ,  step[8], 0, 0, ierflg);
  fMinuit->mnparm(9,  "s gw B" , vstart[9] ,  step[9], 0, 0, ierflg);
  fMinuit->mnparm(10, "s gw C" , vstart[10], step[10], 0, 0, ierflg);
  fMinuit->mnparm(11, "b lw A" , vstart[11], step[11], 0, 0, ierflg);
  fMinuit->mnparm(12, "b lw B" , vstart[12], step[12], 0, 0, ierflg);
  fMinuit->mnparm(13, "b lw C" , vstart[13], step[13], 0, 0, ierflg);
  fMinuit->mnparm(14, "b shift", vstart[14], step[14], 0, 0, ierflg);
  fMinuit->mnparm(15, "b gw A" , vstart[15], step[15], 0, 0, ierflg);
  fMinuit->mnparm(16, "b gw B" , vstart[16], step[16], 0, 0, ierflg);
  fMinuit->mnparm(17, "b gw C" , vstart[17], step[17], 0, 0, ierflg);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("s Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 0, ierflg);//0.82, 0.90, ierflg);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  slwA  , slwA_error);
  fMinuit->GetParameter(1,  slwB  , slwB_error);
  fMinuit->GetParameter(2,  slwC  , slwC_error);
  fMinuit->GetParameter(3,  smpvA , smpvA_error);
  fMinuit->GetParameter(4,  smpvB , smpvB_error);
  fMinuit->GetParameter(5,  smpvC , smpvC_error);
  fMinuit->GetParameter(6,  smpvD , smpvD_error);
  fMinuit->GetParameter(7,  smpvR , smpvR_error);
  fMinuit->GetParameter(8,  sgwA  , sgwA_error);
  fMinuit->GetParameter(9,  sgwB  , sgwB_error);
  fMinuit->GetParameter(10, sgwC  , sgwC_error);
  fMinuit->GetParameter(11, blwA  , blwA_error);
  fMinuit->GetParameter(12, blwB  , blwB_error);
  fMinuit->GetParameter(13, blwC  , blwC_error);
  fMinuit->GetParameter(14, bshift, bshift_error);
  fMinuit->GetParameter(15, bgwA  , bgwA_error);
  fMinuit->GetParameter(16, bgwB  , bgwB_error);
  fMinuit->GetParameter(17, bgwC  , bgwC_error);
  std::vector<std::pair<double,double>> sn;
  std::vector<std::pair<double,double>> bn;
  for(int ipar = 0; ipar < NBINS; ipar++){
    double snorm, snorm_error;//, bnorm, bnorm_error;
    fMinuit->GetParameter(ipar+CPAR, snorm, snorm_error);
    sn.push_back(std::make_pair(snorm, snorm_error));
    //fMinuit->GetParameter(ipar+CPAR+NBINS, bnorm, bnorm_error);
    bn.push_back(std::make_pair(1-snorm, snorm_error));
  }

  GetSignal()->SetClwA(std::make_pair(slwA,slwA_error));
  GetSignal()->SetClwB(std::make_pair(slwB,slwB_error));
  GetSignal()->SetClwC(std::make_pair(slwC,slwC_error));
  GetSignal()->SetCmpvA(std::make_pair(smpvA,smpvA_error));
  GetSignal()->SetCmpvB(std::make_pair(smpvB,smpvB_error));
  GetSignal()->SetCmpvC(std::make_pair(smpvC,smpvR_error));
  GetSignal()->SetCmpvD(std::make_pair(smpvD,smpvC_error));
  GetSignal()->SetCmpvR(std::make_pair(smpvR,smpvD_error));
  GetSignal()->SetCgwA(std::make_pair(sgwA,sgwA_error));
  GetSignal()->SetCgwB(std::make_pair(sgwB,sgwB_error));
  GetSignal()->SetCgwC(std::make_pair(sgwC,sgwC_error));
  GetSignal()->SetCnorm(sn);

  GetBackground()->SetClwA(std::make_pair(blwA,blwA_error));
  GetBackground()->SetClwB(std::make_pair(blwB,blwB_error));
  GetBackground()->SetClwC(std::make_pair(blwC,blwC_error));
  GetBackground()->SetCmpvA(GetSignal()->GetCmpvA());
  GetBackground()->SetCmpvB(GetSignal()->GetCmpvB());
  GetBackground()->SetCmpvC(GetSignal()->GetCmpvC());
  GetBackground()->SetCmpvD(GetSignal()->GetCmpvD());
  GetBackground()->SetCmpvR(GetSignal()->GetCmpvR());
  GetBackground()->SetCshift(std::make_pair(bshift,bshift_error));
  GetBackground()->SetCgwA(std::make_pair(bgwA,bgwA_error));
  GetBackground()->SetCgwB(std::make_pair(bgwB,bgwB_error));
  GetBackground()->SetCgwC(std::make_pair(bgwC,bgwC_error));
  GetBackground()->SetCnorm(bn);
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnSignalPlusBackgroundShift(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************

  const int CPAR = 18;
  const int NBINS = CSMinuit->fh.size();
  
  //set each parameter
  double slwA  = par[0];
  double slwB  = par[1];
  double slwC  = par[2];
  double smpvA = par[3];
  double smpvB = par[4];
  double smpvC = par[5];
  double smpvD = par[6];
  double smpvR = par[7];
  double sgwA  = par[8];
  double sgwB  = par[9];
  double sgwC  = par[10];
  double blwA  = par[11];
  double blwB  = par[12];
  double blwC  = par[13];
  double shift = par[14];
  double bgwA  = par[15];
  double bgwB  = par[16];
  double bgwC  = par[17];
  
  //define function to fit to each histogram
  double slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::DoubleLangaus,1,30,8);
  for(int ibin = 0; ibin < NBINS; ibin++){
    //get RR depending parameters
    double slw_par[]  = {slwA,slwB,slwC,0};
    double smpv_par[] = {smpvA,smpvB,smpvC,smpvD,smpvR,0};
    double sgw_par[]  = {sgwA,sgwB,sgwC,0};
    double blw_par[]  = {blwA,blwB,blwC,0};
    double bmpv_par[] = {smpvA,smpvB,smpvC,smpvD,smpvR,shift};
    double bgw_par[]  = {bgwA,bgwB,bgwC,0};
    double RR_par[]   = {CSMinuit->fRR[ibin].first};
    
    slw   = CoherentFitUtils::ABCParametrization(RR_par,slw_par);
    smpv  = CoherentFitUtils::ABCDRParametrization(RR_par,smpv_par);
    sgw   = CoherentFitUtils::ABCParametrization(RR_par,sgw_par);
    snorm = par[CPAR+ibin];
    blw   = CoherentFitUtils::ABCParametrization(RR_par,blw_par);
    bmpv  = CoherentFitUtils::ABCDRParametrization(RR_par,bmpv_par);
    bgw   = CoherentFitUtils::ABCParametrization(RR_par,bgw_par);
    bnorm = 1-par[CPAR+ibin];
    
    flg->SetParameters(slw,smpv,snorm,sgw,blw,bmpv,bnorm,bgw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//shift and withs as cuadratic sums from signal widths
//********************************************************************
void CoherentSample::CoherentFitBackground3Par(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 3;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackground3Par);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {0.1,  -1, 0.1};
  Double_t step[NPAR]   = {0.1, 0.1, 0.1};
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = fInorm[ipar].first;
    step[ipar+CPAR]   = 0.1;
  }
  fMinuit->mnparm(0,  "lw_shift" ,  vstart[0],  step[0],  0, 0, ierflg);
  fMinuit->mnparm(1,  "mpv_shift",  vstart[1],  step[1],  0, 0, ierflg);
  fMinuit->mnparm(2,  "gw_shift" ,  vstart[2],  step[2],  0, 0, ierflg);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 1, ierflg);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fClwQa.first,  fClwQa.second);
  fMinuit->GetParameter(1,  fCshift.first, fCshift.second);
  fMinuit->GetParameter(2,  fCgwQa.first,  fCgwQa.second);

  for(int ipar = 0; ipar < NBINS; ipar++){
    double norm, norm_error;
    fMinuit->GetParameter(ipar+CPAR, norm, norm_error);
    fCnorm.push_back(std::make_pair(norm, norm_error));
  }

  fClwA = fTrueSignal->GetClwA();
  fClwB = fTrueSignal->GetClwB();
  fClwC = fTrueSignal->GetClwC();
  fCmpvA = fTrueSignal->GetCmpvA();
  fCmpvB = fTrueSignal->GetCmpvB();
  fCmpvC = fTrueSignal->GetCmpvC();
  fCmpvD = fTrueSignal->GetCmpvD();
  fCmpvR = fTrueSignal->GetCmpvR();
  fCgwA = fTrueSignal->GetCgwA();
  fCgwB = fTrueSignal->GetCgwB();
  fCgwC = fTrueSignal->GetCgwC();
  
  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackground3Par(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  const int CPAR = 3;
  
  //set each parameter
  double lwA   = CSMinuit->GetTrueSignal()->GetClwA().first;
  double lwB   = CSMinuit->GetTrueSignal()->GetClwB().first;
  double lwC   = CSMinuit->GetTrueSignal()->GetClwC().first;
  double mpvA  = CSMinuit->GetTrueSignal()->GetCmpvA().first;
  double mpvB  = CSMinuit->GetTrueSignal()->GetCmpvB().first;
  double mpvC  = CSMinuit->GetTrueSignal()->GetCmpvC().first;
  double mpvD  = CSMinuit->GetTrueSignal()->GetCmpvD().first;
  double mpvR  = CSMinuit->GetTrueSignal()->GetCmpvR().first;
  double gwA   = CSMinuit->GetTrueSignal()->GetCgwA().first;
  double gwB   = CSMinuit->GetTrueSignal()->GetCgwB().first;
  double gwC   = CSMinuit->GetTrueSignal()->GetCgwC().first;
  double lw_s  = par[0];
  double mpv_s = par[1];
  double gw_s  = par[2];
  
  //define function to fit to each histogram
  double lw,mpv,norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::Langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    double lw_par[]   = {lwA,lwB,lwC,lw_s};
    double mpv_par[]  = {mpvA,mpvB,mpvC,mpvD,mpvR,mpv_s};
    double gw_par[]   = {gwA,gwB,gwC,gw_s};
    double RR_par[]   = {CSMinuit->fRR[ibin].first};
    lw   = CoherentFitUtils::ABCParametrization(RR_par,lw_par);
    mpv  = CoherentFitUtils::ABCDRParametrization(RR_par,mpv_par);
    gw   = CoherentFitUtils::ABCParametrization(RR_par,gw_par);
    norm = par[CPAR+ibin];
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}

//shift on data and lw
/*
//********************************************************************
void CoherentSample::CoherentFitBackground(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 4;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackground);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {0, fCbgwA.first, fCbgwB.first, fCbgwC.first};
  Double_t step[NPAR]   = {1,    0.1,     0.1,   0.1};
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = fIbnorm[ipar].first;
    step[ipar+CPAR]   = 0.1;
  }
  fMinuit->mnparm(0,  "shift",  vstart[0],  step[0],  0, 0, ierflg);
  fMinuit->mnparm(1,  "gwA"  ,  vstart[1],  step[1],  0, 0, ierflg);
  fMinuit->mnparm(2,  "gwB"  ,  vstart[2],  step[2],  0, 0, ierflg);
  fMinuit->mnparm(3,  "gwC"  ,  vstart[3],  step[3],  0, 0, ierflg);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 1, ierflg);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fCbshift.first,  fCbshift.second);
  fMinuit->GetParameter(1,  fCbgwA.first  ,  fCbgwA.second);
  fMinuit->GetParameter(2,  fCbgwB.first  ,  fCbgwB.second);
  fMinuit->GetParameter(3,  fCbgwC.first  ,  fCbgwC.second);
  for(int ipar = 0; ipar < NBINS; ipar++){
    double norm, norm_error;
    fMinuit->GetParameter(ipar+CPAR, norm, norm_error);
    fCbnorm.push_back(std::make_pair(norm, norm_error));
  }

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackground(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  const int CPAR = 4;
  
  //set each parameter
  double shift = par[0];
  double lwA   = CSMinuit->GetAssociatedSignal()->GetCslwA().first;
  double lwB   = CSMinuit->GetAssociatedSignal()->GetCslwB().first;
  double lwC   = CSMinuit->GetAssociatedSignal()->GetCslwC().first;
  double mpvA  = CSMinuit->GetAssociatedSignal()->GetCsmpvA().first;
  double mpvB  = CSMinuit->GetAssociatedSignal()->GetCsmpvB().first;
  double mpvC  = CSMinuit->GetAssociatedSignal()->GetCsmpvC().first;
  double mpvD  = CSMinuit->GetAssociatedSignal()->GetCsmpvD().first;
  double mpvR  = CSMinuit->GetAssociatedSignal()->GetCsmpvR().first;
  double gwA   = par[1];
  double gwB   = par[2];
  double gwC   = par[3];
  
  //define function to fit to each histogram
  double lw,mpv,norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    lw   = CoherentFitUtils::ABCParametrization(CSMinuit->fRR[ibin].first+shift,lwA,lwB,lwC);
    mpv  = CoherentFitUtils::ABCDRParametrization(CSMinuit->fRR[ibin].first+shift,mpvA,mpvB,mpvC,mpvD,mpvR);
    gw   = CoherentFitUtils::ABCParametrization(CSMinuit->fRR[ibin].first,gwA,gwB,gwC);
    norm = par[CPAR+ibin];
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}
 */

//shift everywhere
/*//********************************************************************
void CoherentSample::CoherentFitBackground(){
//********************************************************************

  CSMinuit = this;
  
  //create Minuit
  const int CPAR = 1;
  const int NBINS = fh.size();
  const int NPAR = CPAR + NBINS;
  fMinuit = new TMinuit(NPAR);
  fMinuit->SetFCN(fcnBackground);
  
  Double_t arglist[10];
  Int_t ierflg = 0;
  
  arglist[0] = 1;
  fMinuit->mnexcm("SET ERR", arglist ,1,ierflg);
  
  //Set starting values and step sizes for parameters
  Double_t vstart[NPAR] = {0};
  Double_t step[NPAR]   = {10};
  for(int ipar = 0; ipar < NBINS; ipar++){
    vstart[ipar+CPAR] = fIbnorm[ipar].first;
    step[ipar+CPAR]   = 0.1;
  }
  fMinuit->mnparm(0,  "shift",  vstart[0],  step[0],  0, 0, ierflg);
  for(int ipar = 0; ipar < NBINS; ipar++){
    std::stringstream ssi;
    ssi << ipar;
    fMinuit->mnparm(ipar+CPAR, ("Ar "+ssi.str()+"").c_str(),
		    vstart[ipar+CPAR], step[ipar+CPAR], 0, 1, ierflg);
  }
  
  // Now ready for minimization step
  arglist[0] = 50000;
  arglist[1] = 1.;
  fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
  
  // Print results
  Double_t amin,edm,errdef;
  Int_t nvpar,nparx,icstat;
  fMinuit->mnstat(amin,edm,errdef,nvpar,nparx,icstat);
  fMinuit->mnprin(3,amin);
  
  //retrieve parameters for next stage
  fMinuit->GetParameter(0,  fCbshift.first,  fCbshift.second);
  for(int ipar = 0; ipar < NBINS; ipar++){
    double norm, norm_error;
    fMinuit->GetParameter(ipar+CPAR, norm, norm_error);
    fCbnorm.push_back(std::make_pair(norm, norm_error));
  }

  StoreCoherentFits();
}

//********************************************************************
void CoherentSample::fcnBackground(Int_t &npar, Double_t *gin, Double_t &f, Double_t *par, Int_t iflag){
//********************************************************************
  
  const int CPAR = 1;
  
  //set each parameter
  double lwA   = CSMinuit->GetAssociatedSignal()->GetCslwA().first;
  double lwB   = CSMinuit->GetAssociatedSignal()->GetCslwB().first;
  double lwC   = CSMinuit->GetAssociatedSignal()->GetCslwC().first;
  double mpvA  = CSMinuit->GetAssociatedSignal()->GetCsmpvA().first;
  double mpvB  = CSMinuit->GetAssociatedSignal()->GetCsmpvB().first;
  double mpvC  = CSMinuit->GetAssociatedSignal()->GetCsmpvC().first;
  double mpvD  = CSMinuit->GetAssociatedSignal()->GetCsmpvD().first;
  double mpvR  = CSMinuit->GetAssociatedSignal()->GetCsmpvR().first;
  double gwA   = CSMinuit->GetAssociatedSignal()->GetCsgwA().first;
  double gwB   = CSMinuit->GetAssociatedSignal()->GetCsgwB().first;
  double gwC   = CSMinuit->GetAssociatedSignal()->GetCsgwC().first;
  double shift = par[0];
  
  //define function to fit to each histogram
  double lw,mpv,norm,gw;
  double Likelihood = 0;
  TF1* flg = new TF1("flg",CoherentFitUtils::langaus,1,30,4);
  for(int ibin = 0; ibin < (int)CSMinuit->fh.size(); ibin++){
    //get RR depending parameters
    lw   = CoherentFitUtils::ABCParametrization(CSMinuit->fRR[ibin].first+shift,lwA,lwB,lwC);
    mpv  = CoherentFitUtils::ABCDRParametrization(CSMinuit->fRR[ibin].first+shift,mpvA,mpvB,mpvC,mpvD,mpvR);
    gw   = CoherentFitUtils::ABCParametrization(CSMinuit->fRR[ibin].first+shift,gwA,gwB,gwC);
    norm = par[CPAR+ibin];
    flg->SetParameters(lw,mpv,norm,gw);
    Likelihood = Likelihood + CoherentFitUtils::ComputeLikelihood(CSMinuit->fh[ibin],flg,CSMinuit->fIntegral[ibin]);
  }
  f = -Likelihood;
}*/

//SIGNAL PLUS BACKGROUND MODELS
//lw,gw free, mpv shift.

